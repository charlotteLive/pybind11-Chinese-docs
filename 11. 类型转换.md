## 11. ç±»å‹è½¬æ¢

é™¤äº†æ”¯æŒè·¨è¯­è¨€å‡½æ•°è°ƒç”¨ï¼Œpybind11è¿™ç±»ç»‘å®šå·¥å…·å¿…é¡»å¤„ç†çš„ä¸€ä¸ªåŸºæœ¬é—®é¢˜å°±æ˜¯ï¼Œæä¾›åœ¨C++ä¸­è®¿é—®åŸç”ŸPythonç±»å‹çš„æ–¹å¼ï¼Œåä¹‹äº¦ç„¶ã€‚æœ‰ä¸‰ç§å®Œå…¨ä¸åŒçš„æ–¹æ³•åšåˆ°è¿™ç‚¹ï¼Œæ¯ç§æ–¹æ³•é€‚ç”¨æ€§å–å†³äºä½ ä½¿ç”¨çš„ç¯å¢ƒã€‚

1. ä»»æ„ä¾§ä½¿ç”¨åŸç”Ÿçš„C++ç±»å‹ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå¿…é¡»ä½¿ç”¨pybind11ç”Ÿæˆç±»å‹çš„ç»‘å®šï¼ŒPythonæ‰èƒ½ä½¿ç”¨å®ƒã€‚
2. ä»»æ„ä¾§ä½¿ç”¨åŸç”Ÿçš„Pythonç±»å‹ã€‚åŒæ ·éœ€è¦åŒ…è£…åï¼ŒC++å‡½æ•°æ‰èƒ½å¤Ÿä½¿ç”¨å®ƒã€‚
3. C++ä¾§ä½¿ç”¨åŸç”ŸC++ç±»å‹ï¼ŒPythonä¾§ä½¿ç”¨åŸç”ŸPythonç±»å‹ã€‚pybind11ç§°å…¶ä¸ºç±»å‹è½¬æ¢ã€‚
   æŸç§æ„ä¹‰ä¸‹ï¼Œåœ¨ä»»æ„ä¾§ä½¿ç”¨åŸç”Ÿç±»å‹ï¼Œç±»å‹è½¬æ¢æ˜¯æœ€è‡ªç„¶çš„é€‰é¡¹ã€‚è¯¥æ–¹æ³•ä¸»è¦çš„ç¼ºç‚¹æ˜¯ï¼Œæ¯æ¬¡Pythonå’ŒC++ä¹‹é—´è½¬æ¢æ—¶éƒ½éœ€è¦æ‹·è´ä¸€ä»½æ•°æ®ï¼Œå› ä¸ºC++å’ŒPythonçš„å¯¹ç›¸åŒç±»å‹çš„å†…å­˜å¸ƒå±€ä¸ä¸€æ ·ã€‚
   pybind11å¯ä»¥è‡ªåŠ¨å®Œæˆå¤šç§ç±»å‹çš„è½¬æ¢ã€‚åé¢ä¼šæä¾›æ‰€æœ‰å†…ç½®è½¬æ¢çš„è¡¨æ ¼ã€‚

ä¸‹é¢çš„å°èŠ‚å°†æ›´è¯¦ç»†åœ°è®¨è®ºè¿™äº›é€‰é¡¹ä¹‹é—´çš„åŒºåˆ«ã€‚

### 11.1 æ¦‚è¿°

**1. Native type in C++, wrapper in Python**

åœ¨â€œé¢å¯¹å¯¹è±¡ç¼–ç¨‹â€ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬è¯¦ç»†ä»‹ç»äº†é€šè¿‡`py::class_`å…¬å¼€è‡ªå®šä¹‰C++ç±»å‹çš„æ–¹æ³•ã€‚è¿™é‡Œï¼Œåº•å±‚çš„æ•°æ®ç»“æ„ä»ç„¶æ˜¯åŸå§‹çš„C++ç±»ï¼Œè€Œ`py::class_`åŒ…è£…åˆ™æä¾›äº†Pythonä¾§çš„æ¥å£ã€‚å½“ä¸€ä¸ªå¯¹è±¡ä»C++ä¾§å‘é€åˆ°Pythonä¾§æ—¶ï¼Œpybind11ä»…ä»…åœ¨åŸå§‹çš„C++å¯¹è±¡ä¸Šå¢åŠ äº†ä¸€å±‚åŒ…è£…è€Œå·²ã€‚ä»Pythonä¾§è·å–å®ƒä¹Ÿä»…ä»…æ˜¯æ’•æ‰äº†åŒ…è£…è€Œå·²ã€‚

**2. Wrapper in C++, native type in Python**

è¿™ä¸ä¸Šé¢æ˜¯å®Œå…¨ç›¸åçš„æƒ…å†µã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªåŸç”Ÿçš„Pythonç±»å‹ï¼Œå¦‚tupleæˆ–listã€‚åœ¨C++ä¾§è·å–è¿™ä¸ªæ•°æ®çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨`py::object`æ—åŒ…è£…å™¨ã€‚è¿™å°†åœ¨åç»­ç« èŠ‚è¯¦ç»†è§£é‡Šã€‚è¿™é‡Œä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š

```c++
void print_list(py::list my_list) {
    for (auto item : my_list)
        std::cout << item << " ";
}
```

```python
>>> print_list([1, 2, 3])
1 2 3
```

Pythonçš„listä»…ä»…æ˜¯åŒ…è£¹åœ¨äº†C++ `py::list`ç±»é‡Œï¼Œå¹¶æ²¡æœ‰ä»…ä»…ä»»ä½•è½¬æ¢ã€‚å®ƒçš„æ ¸å¿ƒä»»ç„¶æ˜¯ä¸€ä¸ªPythonå¯¹è±¡ã€‚æ‹·è´ä¸€ä¸ª`py::list`ä¼šåƒPythonä¸­ä¸€æ ·å¢åŠ å¼•ç”¨è®¡æ•°ã€‚å°†å¯¹è±¡è¿”å›åˆ°Pythonä¾§ï¼Œå°†å»æ‰è¿™å±‚å°è£…ã€‚

**3. Converting between native C++ and Python types**

å‰é¢ä¸¤ç§æƒ…å†µï¼Œæˆ‘ä»¬åœ¨ä¸€ç§è¯­è¨€ä¸­ä½¿ç”¨åŸç”Ÿç±»å‹ï¼Œè€Œåœ¨å¦ä¸€ç§è¯­è¨€ä¸­ä½¿ç”¨å®ƒçš„åŒ…è£…ç±»å‹ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨ä¸¤ä¾§éƒ½ä½¿ç”¨åŸç”Ÿç±»å‹ï¼Œå¹¶å¯¹ä»–ä»¬è¿›è¡Œç±»å‹è½¬æ¢ã€‚

```c++
void print_vector(const std::vector<int> &v) {
    for (auto item : v)
        std::cout << item << "\n";
}
```

```python
>>> print_vector([1, 2, 3])
1 2 3
```

è¿™ä¸ªä¾‹å­ä¸­ï¼Œpybind11å°†åˆ›å»ºä¸€ä¸ª`std::vector<int>`å®ä¾‹ï¼Œå¹¶ä»Python listä¸­æ‹·è´æ¯ä¸ªå…ƒç´ ã€‚ç„¶åå°†è¯¥å®ä¾‹ä¼ é€’ç»™`print_vector`ã€‚åŒæ ·çš„äº‹æƒ…å‘ç”Ÿåœ¨å¦ä¸€ä¸ªæ–¹å‘ï¼šæ–°å»ºäº†ä¸€ä¸ªlistï¼Œå¹¶ä»C++çš„vectorä¸­è·å–å…ƒç´ å€¼ã€‚

å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼Œå¤šæ•°è½¬æ¢æ˜¯å¼€ç®±å³ç”¨çš„ã€‚ä»–ä»¬ç›¸å½“æ–¹ä¾¿ï¼Œä½†è¯·è®°ä½ä¸€ç‚¹ï¼Œè¿™äº›è½¬æ¢æ˜¯åŸºäºæ•°æ®æ‹·è´çš„ã€‚è¿™å¯¹å°å‹çš„ä¸å˜çš„ç±»å‹ç›¸å½“å‹å¥½ï¼Œå¯¹äºå¤§å‹æ•°æ®ç»“æ„åˆ™ç›¸å½“æ˜‚è´µã€‚è¿™å¯ä»¥é€šè¿‡è‡ªå®šä¹‰åŒ…è£…ç±»å‹é‡è½½è‡ªåŠ¨è½¬æ¢æ¥è§„é¿ï¼ˆå¦‚ä¸Šé¢æåˆ°çš„æ–¹æ³•1ï¼‰ã€‚This requires some manual effort and more details are available in the [Making opaque types](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque) section.

**å†…ç½®è½¬æ¢çš„åˆ—è¡¨**

ä¸‹é¢åŸºç¡€æ•°æ®ç±»å‹æ˜¯å¼€ç®±å³ç”¨çš„ï¼ˆæœ‰äº›å¯èƒ½éœ€è¦includeé¢å¤–çš„å¤´æ–‡ä»¶ï¼‰ã€‚

| Data type                                       | Description                                                  | Header file             |
| ----------------------------------------------- | ------------------------------------------------------------ | ----------------------- |
| `int8_t`, `uint8_t`                             | 8-bit integers                                               | `pybind11/pybind11.h`   |
| `int16_t`, `uint16_t`                           | 16-bit integers                                              | `pybind11/pybind11.h`   |
| `int32_t`, `uint32_t`                           | 32-bit integers                                              | `pybind11/pybind11.h`   |
| `int64_t`, `uint64_t`                           | 64-bit integers                                              | `pybind11/pybind11.h`   |
| `ssize_t`, `size_t`                             | Platform-dependent size                                      | `pybind11/pybind11.h`   |
| `float`, `double`                               | Floating point types                                         | `pybind11/pybind11.h`   |
| `bool`                                          | Two-state Boolean type                                       | `pybind11/pybind11.h`   |
| `char`                                          | Character literal                                            | `pybind11/pybind11.h`   |
| `char16_t`                                      | UTF-16 character literal                                     | `pybind11/pybind11.h`   |
| `char32_t`                                      | UTF-32 character literal                                     | `pybind11/pybind11.h`   |
| `wchar_t`                                       | Wide character literal                                       | `pybind11/pybind11.h`   |
| `const char *`                                  | UTF-8 string literal                                         | `pybind11/pybind11.h`   |
| `const char16_t *`                              | UTF-16 string literal                                        | `pybind11/pybind11.h`   |
| `const char32_t *`                              | UTF-32 string literal                                        | `pybind11/pybind11.h`   |
| `const wchar_t *`                               | Wide string literal                                          | `pybind11/pybind11.h`   |
| `std::string`                                   | STL dynamic UTF-8 string                                     | `pybind11/pybind11.h`   |
| `std::u16string`                                | STL dynamic UTF-16 string                                    | `pybind11/pybind11.h`   |
| `std::u32string`                                | STL dynamic UTF-32 string                                    | `pybind11/pybind11.h`   |
| `std::wstring`                                  | STL dynamic wide string                                      | `pybind11/pybind11.h`   |
| `std::string_view`, `std::u16string_view`, etc. | STL C++17 string views                                       | `pybind11/pybind11.h`   |
| `std::pair<T1, T2>`                             | Pair of two custom types                                     | `pybind11/pybind11.h`   |
| `std::tuple<...>`                               | Arbitrary tuple of types                                     | `pybind11/pybind11.h`   |
| `std::reference_wrapper<...>`                   | Reference type wrapper                                       | `pybind11/pybind11.h`   |
| `std::complex<T>`                               | Complex numbers                                              | `pybind11/complex.h`    |
| `std::array<T, Size>`                           | STL static array                                             | `pybind11/stl.h`        |
| `std::vector<T>`                                | STL dynamic array                                            | `pybind11/stl.h`        |
| `std::deque<T>`                                 | STL double-ended queue                                       | `pybind11/stl.h`        |
| `std::valarray<T>`                              | STL value array                                              | `pybind11/stl.h`        |
| `std::list<T>`                                  | STL linked list                                              | `pybind11/stl.h`        |
| `std::map<T1, T2>`                              | STL ordered map                                              | `pybind11/stl.h`        |
| `std::unordered_map<T1, T2>`                    | STL unordered map                                            | `pybind11/stl.h`        |
| `std::set<T>`                                   | STL ordered set                                              | `pybind11/stl.h`        |
| `std::unordered_set<T>`                         | STL unordered set                                            | `pybind11/stl.h`        |
| `std::optional<T>`                              | STL optional type (C++17)                                    | `pybind11/stl.h`        |
| `std::experimental::optional<T>`                | STL optional type (exp.)                                     | `pybind11/stl.h`        |
| `std::variant<...>`                             | Type-safe union (C++17)                                      | `pybind11/stl.h`        |
| `std::filesystem::path<T>`                      | STL path (C++17) [1](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#id2) | `pybind11/stl.h`        |
| `std::function<...>`                            | STL polymorphic function                                     | `pybind11/functional.h` |
| `std::chrono::duration<...>`                    | STL time duration                                            | `pybind11/chrono.h`     |
| `std::chrono::time_point<...>`                  | STL date/time                                                | `pybind11/chrono.h`     |
| `Eigen::Matrix<...>`                            | Eigen: dense matrix                                          | `pybind11/eigen.h`      |
| `Eigen::Map<...>`                               | Eigen: mapped memory                                         | `pybind11/eigen.h`      |
| `Eigen::SparseMatrix<...>`                      | Eigen: sparse matrix                                         | `pybind11/eigen.h`      |

### 11.2 Strings, bytes and Unicode conversions

> Note: æœ¬èŠ‚è®¨è®ºçš„stringå¤„ç†åŸºäºPython3 stringsã€‚å¯¹äºpython2.7ï¼Œä½¿ç”¨`unicode`æ›¿æ¢`str`ï¼Œ`str`æ›¿æ¢`bytes`ã€‚Python2.7ç”¨äºæœ€å¥½ä½¿ç”¨`from __future__ import unicode_literals`é¿å…æ— æ„é—´ä½¿ç”¨`str`ä»£æ›¿`unicode`ã€‚

#### 11.2.1 ä¼ é€’Python stringsåˆ°C++

å½“å‘ä¸€ä¸ªæ¥æ”¶`std::string`æˆ–`char *`å‚æ•°çš„å‡½æ•°ä¼ é€’Pythonçš„`str`æ—¶ï¼Œpybind11ä¼šå°†Pythonå­—ç¬¦ä¸²ç¼–ç ä¸ºUTF-8ã€‚æ‰€æœ‰çš„Python `str`éƒ½èƒ½å¤Ÿç”¨UTF-8ç¼–ç ï¼Œæ‰€ä»¥è¿™ä¸ªæ“ä½œä¸ä¼šå¤±è´¥ã€‚

C++è¯­è¨€æ˜¯encoding agnosticã€‚ç¨‹åºå‘˜è´Ÿè´£å¤„ç†ç¼–ç ï¼Œæœ€ç®€å•çš„åšæ³•å°±æ˜¯æ¯å¤„éƒ½ä½¿ç”¨UTF-8ã€‚

```c++
m.def("utf8_test",
    [](const std::string &s) {
        cout << "utf-8 is icing on the cake.\n";
        cout << s;
    }
);
m.def("utf8_charptr",
    [](const char *s) {
        cout << "My favorite food is\n";
        cout << s;
    }
);
```

```python
>>> utf8_test("ğŸ‚")
utf-8 is icing on the cake.
ğŸ‚

>>> utf8_charptr("ğŸ•")
My favorite food is
ğŸ•
```

> Note: æœ‰äº›ç»ˆç«¯æ¨¡æ‹Ÿå™¨ä¸æ”¯æŒUTF-8æˆ–emojiå­—ä½“ï¼Œä¸Šé¢çš„ä¾‹å­å¯èƒ½æ— æ³•æ˜¾ç¤ºã€‚

æ— è®ºC++å‡½æ•°çš„å‚æ•°æ˜¯ä¼ å€¼æˆ–å¼•ç”¨ï¼Œæ˜¯å¦æ˜¯constï¼Œç»“æœéƒ½æ˜¯ä¸€æ ·çš„ã€‚

**å‘C++ä¼ é€’byteså¯¹è±¡**

å‘æ¥æ”¶`std::string`æˆ–`char *`ç±»å‹å‚æ•°çš„C++å‡½æ•°ä¼ é€’Python byteså¯¹è±¡æ— éœ€è½¬æ¢ã€‚åœ¨Python3ä¸Šï¼Œå¦‚æœæƒ³è¦å‡½æ•°åªæ¥æ”¶bytesï¼Œä¸æ¥æ”¶strï¼Œå¯ä»¥å£°æ˜å‚æ•°ç±»å‹ä¸º`py::bytes`ã€‚

#### 11.2.2 å‘Pythonè¿”å›C++ å­—ç¬¦ä¸²

å½“C++å‡½æ•°è¿”å›`std::string`æˆ–`char*`å‚æ•°ç»™Pythonè°ƒç”¨è€…æ—¶ï¼Œpybind11ä¼šå°†å­—ç¬¦ä¸²ä»¥UTF-8æ ¼å¼è§£ç ç»™åŸç”ŸPython strï¼Œç±»ä¼¼äºPythonä¸­çš„`bytes.decode('utf-8')`ã€‚å¦‚æœéšå¼è½¬æ¢å¤±è´¥ï¼Œpybind11å°†ä¼šæŠ›å‡ºå¼‚å¸¸`UnicodeDecodeError`ã€‚

```c++
m.def("std_string_return",
    []() {
        return std::string("This string needs to be UTF-8 encoded");
    }
);
```

```python
>>> isinstance(example.std_string_return(), str)
True
```

å› ä¸ºUTF-8åŒ…å«çº¯ASCIIï¼Œè¿”å›ä¸€ä¸ªçº¯ASCIIå­—ç¬¦ä¸²åˆ°Pythonæ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚å¦åˆ™å°±éœ€è¦ç¡®ä¿ç¼–ç æ˜¯æœ‰æ•ˆçš„UTF-8ã€‚

> Warning: éšå¼è½¬æ¢å‡å®š`char *`å­—ç¬¦ä¸²ä»¥nullä¸ºç»“æŸç¬¦ã€‚è‹¥ä¸æ˜¯ï¼Œå°†å¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚

**æ˜¾å¼è½¬æ¢**

å¦‚æœC++ä»£ç æ„é€ äº†ä¸€ä¸ªéUTF-8çš„stringå­—ç¬¦ä¸²ï¼Œå¯ä»¥æ‰§è¡Œæ˜¾å¼è½¬æ¢å¹¶è¿”å›`py::str`å¯¹è±¡ã€‚æ˜¾å¼è½¬æ¢ä¸éšå¼è½¬æ¢çš„å¼€é”€ç›¸åŒã€‚

```c++
// This uses the Python C API to convert Latin-1 to Unicode
m.def("str_output",
    []() {
        std::string s = "Send your r\xe9sum\xe9 to Alice in HR"; // Latin-1
        py::str py_s = PyUnicode_DecodeLatin1(s.data(), s.length());
        return py_s;
    }
);
```

```python
>>> str_output()
'Send your rÃ©sumÃ© to Alice in HR'
```

 [Python C API](https://docs.python.org/3/c-api/unicode.html#built-in-codecs)æä¾›äº†ä¸€äº›å†…ç½®çš„ç¼–è§£ç æ–¹æ³•å¯ä»¥ä½¿ç”¨ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“å¦‚libiconv æ¥è½¬æ¢UTF-8ã€‚

**ä¸ä½¿ç”¨ç±»å‹è½¬æ¢æ¥è¿”å›C++å­—ç¬¦ä¸²**

å¦‚æœC++ `std::string`ä¸­çš„æ•°æ®ä¸è¡¨ç¤ºæ–‡æœ¬ï¼Œåˆ™åº”è¯¥ä»¥`bytes`çš„å½¢å¼ä¼ é€’ç»™Pythonï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥è¿”å›ä¸€ä¸ª`py::btyes`å¯¹è±¡ã€‚

```c++
m.def("return_bytes",
    []() {
        std::string s("\xba\xd0\xba\xd0");  // Not valid UTF-8
        return py::bytes(s);  // Return the data without transcoding
    }
);
```

```python
>>> example.return_bytes()
b'\xba\xd0\xba\xd0'
```

æ³¨æ„ï¼špybind11å¯ä»¥å°†bytesæ— éœ€ç¼–ç åœ°è½¬æ¢ä¸º`std::string`ï¼Œä½†ä¸èƒ½ä¸ç»ç¼–ç åœ°éšå¼è½¬æ¢`std::string`åˆ°bytesã€‚

```c++
m.def("asymmetry",
    [](std::string s) {  // Accepts str or bytes from Python
        return s;  // Looks harmless, but implicitly converts to str
    }
);
```

```python
>>> isinstance(example.asymmetry(b"have some bytes"), str)
True

>>> example.asymmetry(b"\xba\xd0\xba\xd0")  # invalid utf-8 as bytes
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xba in position 0: invalid start byte
```

#### 11.2.3 å®½å­—ç¬¦ä¸²

å‘å…¥å‚ä¸º`std::wstring`ã€`wchar_t*`ã€`std::u16string`æˆ–`std::u32string`çš„C++å‡½æ•°ä¼ é€’Python strå¯¹è±¡ï¼Œstrå°†è¢«ç¼–ç ä¸ºUTF-16æˆ–UTF-32ï¼ˆå…·ä½“å“ªç§å–å†³äºC++ç¼–è¯‘å™¨çš„æ”¯æŒï¼‰ã€‚å½“C++å‡½æ•°è¿”å›è¿™äº›ç±»å‹çš„å­—ç¬¦ä¸²åˆ°Python stræ—¶ï¼Œéœ€è¦ä¿è¯å­—ç¬¦ä¸²æ˜¯åˆæ³•çš„UTF-16æˆ–UTF-32ã€‚

```c++
#define UNICODE
#include <windows.h>

m.def("set_window_text",
    [](HWND hwnd, std::wstring s) {
        // Call SetWindowText with null-terminated UTF-16 string
        ::SetWindowText(hwnd, s.c_str());
    }
);
m.def("get_window_text",
    [](HWND hwnd) {
        const int buffer_size = ::GetWindowTextLength(hwnd) + 1;
        auto buffer = std::make_unique< wchar_t[] >(buffer_size);

        ::GetWindowText(hwnd, buffer.data(), buffer_size);

        std::wstring text(buffer.get());

        // wstring will be converted to Python str
        return text;
    }
);
```

> è­¦å‘Šï¼šå¸¦`--enable-unicode=ucs2`é€‰é¡¹ç¼–è¯‘çš„Python 2.7å’Œ3.3ç‰ˆæœ¬å¯èƒ½ä¸æ”¯æŒä¸Šè¿°çš„å®½å­—ç¬¦ä¸²ã€‚

å¤šå­—èŠ‚ç¼–ç åœ°å­—ç¬¦ä¸²ï¼Œå¦‚Shift-JISï¼Œå¿…é¡»è½¬æ¢ä¸ºUTF-8/16/32åï¼Œå†è¿”å›ç»™Pythonã€‚

#### 11.2.4 å­—ç¬¦ç±»å‹

å‘ä¸€ä¸ªå…¥å‚ä¸ºå­—ç¬¦ç±»å‹ï¼ˆchar, wchar_tï¼‰çš„C++å‡½æ•°ï¼Œä¼ é€’Python strï¼ŒC++å‡½æ•°å°†æ¥æ”¶strçš„é¦–å­—ç¬¦ã€‚å¦‚æœå­—ç¬¦ä¸²è¶…è¿‡ä¸€ä¸ªUnicodeå­—ç¬¦é•¿åº¦ï¼Œå°†å¿½ç•¥å°¾éƒ¨å­—èŠ‚ã€‚

å½“C++è¿”å›ä¸€ä¸ªå­—ç¬¦å˜é‡æ—¶ï¼Œå®ƒå°†è¢«è½¬åŒ–ä¸ºå•å­—ç¬¦çš„strå˜é‡ã€‚

```c++
m.def("pass_char", [](char c) { return c; });
m.def("pass_wchar", [](wchar_t w) { return w; });
```

```python
example.pass_char("A")
'A'
```

è™½ç„¶C++å¯ä»¥å°†æ•´æ•°è½¬æ¢ä¸ºå­—ç¬¦ç±»å‹ï¼ˆ`char c = 0x65`ï¼‰ï¼Œpybind11å¹¶ä¸ä¼šéšå¼è½¬æ¢Pythonæ•´æ•°åˆ°å­—ç¬¦ç±»å‹ã€‚å¯ä»¥ä½¿ç”¨`chr()`Pythonå‡½æ•°æ¥å°†æ•´æ•°è½¬æ¢ä¸ºå­—ç¬¦ã€‚

```python
>>> example.pass_char(0x65)
TypeError

>>> example.pass_char(chr(0x65))
'A'
```

å¦‚æœéœ€è¦ä½¿ç”¨8-bitæ•´æ•°ï¼Œå¯ä½¿ç”¨`int8_t`æˆ–`uint8_t`ä½œä¸ºå‚æ•°ç±»å‹ã€‚

#### 11.2.5 Grapheme clusters

A single grapheme may be represented by two or more Unicode characters. For example â€˜Ã©â€™ is usually represented as U+00E9 but can also be expressed as the combining character sequence U+0065 U+0301 (that is, the letter â€˜eâ€™ followed by a combining acute accent). The combining character will be lost if the two-character sequence is passed as an argument, even though it renders as a single grapheme.

```
>>> example.pass_wchar("Ã©")
'Ã©'

>>> combining_e_acute = "e" + "\u0301"

>>> combining_e_acute
'eÌ'

>>> combining_e_acute == "Ã©"
False

>>> example.pass_wchar(combining_e_acute)
'e'
```

Normalizing combining characters before passing the character literal to C++ may resolve *some* of these issues:

```
>>> example.pass_wchar(unicodedata.normalize("NFC", combining_e_acute))
'Ã©'
```

In some languages (Thai for example), there are [graphemes that cannot be expressed as a single Unicode code point](http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries), so there is no way to capture them in a C++ character type.

#### 11.2.6 c++17 string_view

C++17 string views are automatically supported when compiling in C++17 mode. They follow the same rules for encoding and decoding as the corresponding STL string type (for example, a `std::u16string_view` argument will be passed UTF-16-encoded data, and a returned `std::string_view` will be decoded as UTF-8).

### 11.3 STLå®¹å™¨

#### 11.3.1 è‡ªåŠ¨è½¬æ¢

åŒ…å«å¤´æ–‡ä»¶`pybind11/stl.h`åï¼Œè‡ªåŠ¨æ”¯æŒ `std::vector<>`/`std::deque<>`/`std::list<>`/`std::array<>`/`std::valarray<>`, `std::set<>`/`std::unordered_set<>`, å’Œ`std::map<>`/`std::unordered_map<>` åˆ°Python `list`, `set` å’Œ `dict` çš„ç±»å‹è½¬æ¢ã€‚ `std::pair<>` å’Œ`std::tuple<>` ç±»å‹è½¬æ¢åœ¨`pybind11/pybind11.h`ä¸­å·²ç»æ”¯æŒã€‚

éšå¼è½¬æ¢çš„ä¸»è¦ç¼ºç‚¹å°±æ˜¯Pythonå’ŒC++ä¹‹é—´çš„å®¹å™¨ç±»å‹è½¬æ¢éƒ½éœ€è¦æ‹·è´æ•°æ®ï¼Œè¿™å¯¹ç¨‹åºè¯­ä¹‰å’Œæ€§èƒ½æœ‰ä¸€å®šçš„å½±å“ã€‚åç»­ç« èŠ‚å°†ä»‹ç»å¦‚ä½•é¿å…è¯¥é—®é¢˜ã€‚

> Note: è¿™äº›ç±»å‹ä»»æ„åµŒå¥—éƒ½æ˜¯å¯ä»¥çš„ã€‚

#### 11.3.2 C++17åº“çš„å®¹å™¨

`pybind11/stl.h`æ”¯æŒC++17çš„ `std::optional<>` å’Œ`std::variant<>`ï¼ŒC++14çš„`std::experimental::optional<>`ã€‚

C++11ä¸­ä¹Ÿå­˜åœ¨è¿™äº›å®¹å™¨çš„å…¶ä»–ç‰ˆæœ¬ï¼Œå¦‚Boostä¸­ã€‚pybind11æä¾›äº†ä¸€ä¸ªç®€å•çš„æ–¹æ³•`type_caster`æ¥å¤„ç†è¿™äº›ç±»å‹ï¼š

```c++
// `boost::optional` as an example -- can be any `std::optional`-like container
namespace pybind11 { namespace detail {
    template <typename T>
    struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};
}}
```

ä¸Šè¿°å†…å®¹åº”æ”¾åˆ°å¤´æ–‡ä»¶ä¸­ï¼Œå¹¶åœ¨éœ€è¦çš„åœ°æ–¹åŒ…å«å®ƒä»¬ã€‚Similarly, a specialization can be provided for custom variant types:

```c++
// `boost::variant` as an example -- can be any `std::variant`-like container
namespace pybind11 { namespace detail {
    template <typename... Ts>
    struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};

    // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`
    template <>
    struct visit_helper<boost::variant> {
        template <typename... Args>
        static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
            return boost::apply_visitor(args...);
        }
    };
}} // namespace pybind11::detail
```

The `visit_helper` specialization is not required if your `name::variant` provides a `name::visit()` function. For any other function name, the specialization must be included to tell pybind11 how to visit the variant.

> Warning: When converting a `variant` type, pybind11 follows the same rules as when determining which function overload to call ([Overload resolution order](https://pybind11.readthedocs.io/en/stable/advanced/functions.html#overload-resolution)), and so the same caveats hold. In particular, the order in which the `variant`â€™s alternatives are listed is important, since pybind11 will try conversions in this order. This means that, for example, when converting `variant<int, bool>`, the `bool` variant will never be selected, as any Python `bool` is already an `int` and is convertible to a C++ `int`. Changing the order of alternatives (and using `variant<bool, int>`, in this example) provides a solution.

#### 11.3.3 åˆ¶ä½œopaqueç±»å‹









