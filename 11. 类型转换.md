## 11. ç±»å‹è½¬æ¢

é™¤äº†æ”¯æŒè·¨è¯­è¨€å‡½æ•°è°ƒç”¨ï¼Œpybind11è¿™ç±»ç»‘å®šå·¥å…·å¿…é¡»å¤„ç†çš„ä¸€ä¸ªåŸºæœ¬é—®é¢˜å°±æ˜¯ï¼Œæä¾›åœ¨C++ä¸­è®¿é—®åŸç”ŸPythonç±»å‹çš„æ–¹å¼ï¼Œåä¹‹äº¦ç„¶ã€‚æœ‰ä¸‰ç§å®Œå…¨ä¸åŒçš„æ–¹æ³•åšåˆ°è¿™ç‚¹ï¼Œæ¯ç§æ–¹æ³•é€‚ç”¨æ€§å–å†³äºä½ ä½¿ç”¨çš„ç¯å¢ƒã€‚

1. ä»»æ„ä¾§ä½¿ç”¨åŸç”Ÿçš„C++ç±»å‹ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå¿…é¡»ä½¿ç”¨pybind11ç”Ÿæˆç±»å‹çš„ç»‘å®šï¼ŒPythonæ‰èƒ½ä½¿ç”¨å®ƒã€‚
2. ä»»æ„ä¾§ä½¿ç”¨åŸç”Ÿçš„Pythonç±»å‹ã€‚åŒæ ·éœ€è¦åŒ…è£…åï¼ŒC++å‡½æ•°æ‰èƒ½å¤Ÿä½¿ç”¨å®ƒã€‚
3. C++ä¾§ä½¿ç”¨åŸç”ŸC++ç±»å‹ï¼ŒPythonä¾§ä½¿ç”¨åŸç”ŸPythonç±»å‹ã€‚pybind11ç§°å…¶ä¸ºç±»å‹è½¬æ¢ã€‚
   æŸç§æ„ä¹‰ä¸‹ï¼Œåœ¨ä»»æ„ä¾§ä½¿ç”¨åŸç”Ÿç±»å‹ï¼Œç±»å‹è½¬æ¢æ˜¯æœ€è‡ªç„¶çš„é€‰é¡¹ã€‚è¯¥æ–¹æ³•ä¸»è¦çš„ç¼ºç‚¹æ˜¯ï¼Œæ¯æ¬¡Pythonå’ŒC++ä¹‹é—´è½¬æ¢æ—¶éƒ½éœ€è¦æ‹·è´ä¸€ä»½æ•°æ®ï¼Œå› ä¸ºC++å’ŒPythonçš„å¯¹ç›¸åŒç±»å‹çš„å†…å­˜å¸ƒå±€ä¸ä¸€æ ·ã€‚
   pybind11å¯ä»¥è‡ªåŠ¨å®Œæˆå¤šç§ç±»å‹çš„è½¬æ¢ã€‚åé¢ä¼šæä¾›æ‰€æœ‰å†…ç½®è½¬æ¢çš„è¡¨æ ¼ã€‚

ä¸‹é¢çš„å°èŠ‚å°†æ›´è¯¦ç»†åœ°è®¨è®ºè¿™äº›é€‰é¡¹ä¹‹é—´çš„åŒºåˆ«ã€‚

### 11.1 æ¦‚è¿°

**1. Native type in C++, wrapper in Python**

åœ¨â€œé¢å¯¹å¯¹è±¡ç¼–ç¨‹â€ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬è¯¦ç»†ä»‹ç»äº†é€šè¿‡`py::class_`å…¬å¼€è‡ªå®šä¹‰C++ç±»å‹çš„æ–¹æ³•ã€‚è¿™é‡Œï¼Œåº•å±‚çš„æ•°æ®ç»“æ„ä»ç„¶æ˜¯åŸå§‹çš„C++ç±»ï¼Œè€Œ`py::class_`åŒ…è£…åˆ™æä¾›äº†Pythonä¾§çš„æ¥å£ã€‚å½“ä¸€ä¸ªå¯¹è±¡ä»C++ä¾§å‘é€åˆ°Pythonä¾§æ—¶ï¼Œpybind11ä»…ä»…åœ¨åŸå§‹çš„C++å¯¹è±¡ä¸Šå¢åŠ äº†ä¸€å±‚åŒ…è£…è€Œå·²ã€‚ä»Pythonä¾§è·å–å®ƒä¹Ÿä»…ä»…æ˜¯æ’•æ‰äº†åŒ…è£…è€Œå·²ã€‚

**2. Wrapper in C++, native type in Python**

è¿™ä¸ä¸Šé¢æ˜¯å®Œå…¨ç›¸åçš„æƒ…å†µã€‚ç°åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªåŸç”Ÿçš„Pythonç±»å‹ï¼Œå¦‚tupleæˆ–listã€‚åœ¨C++ä¾§è·å–è¿™ä¸ªæ•°æ®çš„ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨`py::object`æ—åŒ…è£…å™¨ã€‚è¿™å°†åœ¨åç»­ç« èŠ‚è¯¦ç»†è§£é‡Šã€‚è¿™é‡Œä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š

```c++
void print_list(py::list my_list) {
    for (auto item : my_list)
        std::cout << item << " ";
}
```

```python
>>> print_list([1, 2, 3])
1 2 3
```

Pythonçš„listä»…ä»…æ˜¯åŒ…è£¹åœ¨äº†C++ `py::list`ç±»é‡Œï¼Œå¹¶æ²¡æœ‰ä»…ä»…ä»»ä½•è½¬æ¢ã€‚å®ƒçš„æ ¸å¿ƒä»»ç„¶æ˜¯ä¸€ä¸ªPythonå¯¹è±¡ã€‚æ‹·è´ä¸€ä¸ª`py::list`ä¼šåƒPythonä¸­ä¸€æ ·å¢åŠ å¼•ç”¨è®¡æ•°ã€‚å°†å¯¹è±¡è¿”å›åˆ°Pythonä¾§ï¼Œå°†å»æ‰è¿™å±‚å°è£…ã€‚

**3. Converting between native C++ and Python types**

å‰é¢ä¸¤ç§æƒ…å†µï¼Œæˆ‘ä»¬åœ¨ä¸€ç§è¯­è¨€ä¸­ä½¿ç”¨åŸç”Ÿç±»å‹ï¼Œè€Œåœ¨å¦ä¸€ç§è¯­è¨€ä¸­ä½¿ç”¨å®ƒçš„åŒ…è£…ç±»å‹ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬åœ¨ä¸¤ä¾§éƒ½ä½¿ç”¨åŸç”Ÿç±»å‹ï¼Œå¹¶å¯¹ä»–ä»¬è¿›è¡Œç±»å‹è½¬æ¢ã€‚

```c++
void print_vector(const std::vector<int> &v) {
    for (auto item : v)
        std::cout << item << "\n";
}
```

```python
>>> print_vector([1, 2, 3])
1 2 3
```

è¿™ä¸ªä¾‹å­ä¸­ï¼Œpybind11å°†åˆ›å»ºä¸€ä¸ª`std::vector<int>`å®ä¾‹ï¼Œå¹¶ä»Python listä¸­æ‹·è´æ¯ä¸ªå…ƒç´ ã€‚ç„¶åå°†è¯¥å®ä¾‹ä¼ é€’ç»™`print_vector`ã€‚åŒæ ·çš„äº‹æƒ…å‘ç”Ÿåœ¨å¦ä¸€ä¸ªæ–¹å‘ï¼šæ–°å»ºäº†ä¸€ä¸ªlistï¼Œå¹¶ä»C++çš„vectorä¸­è·å–å…ƒç´ å€¼ã€‚

å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼Œå¤šæ•°è½¬æ¢æ˜¯å¼€ç®±å³ç”¨çš„ã€‚ä»–ä»¬ç›¸å½“æ–¹ä¾¿ï¼Œä½†è¯·è®°ä½ä¸€ç‚¹ï¼Œè¿™äº›è½¬æ¢æ˜¯åŸºäºæ•°æ®æ‹·è´çš„ã€‚è¿™å¯¹å°å‹çš„ä¸å˜çš„ç±»å‹ç›¸å½“å‹å¥½ï¼Œå¯¹äºå¤§å‹æ•°æ®ç»“æ„åˆ™ç›¸å½“æ˜‚è´µã€‚è¿™å¯ä»¥é€šè¿‡è‡ªå®šä¹‰åŒ…è£…ç±»å‹é‡è½½è‡ªåŠ¨è½¬æ¢æ¥è§„é¿ï¼ˆå¦‚ä¸Šé¢æåˆ°çš„æ–¹æ³•1ï¼‰ã€‚This requires some manual effort and more details are available in the [Making opaque types](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque) section.

**å†…ç½®è½¬æ¢çš„åˆ—è¡¨**

ä¸‹é¢åŸºç¡€æ•°æ®ç±»å‹æ˜¯å¼€ç®±å³ç”¨çš„ï¼ˆæœ‰äº›å¯èƒ½éœ€è¦includeé¢å¤–çš„å¤´æ–‡ä»¶ï¼‰ã€‚

| Data type                                       | Description                                                  | Header file             |
| ----------------------------------------------- | ------------------------------------------------------------ | ----------------------- |
| `int8_t`, `uint8_t`                             | 8-bit integers                                               | `pybind11/pybind11.h`   |
| `int16_t`, `uint16_t`                           | 16-bit integers                                              | `pybind11/pybind11.h`   |
| `int32_t`, `uint32_t`                           | 32-bit integers                                              | `pybind11/pybind11.h`   |
| `int64_t`, `uint64_t`                           | 64-bit integers                                              | `pybind11/pybind11.h`   |
| `ssize_t`, `size_t`                             | Platform-dependent size                                      | `pybind11/pybind11.h`   |
| `float`, `double`                               | Floating point types                                         | `pybind11/pybind11.h`   |
| `bool`                                          | Two-state Boolean type                                       | `pybind11/pybind11.h`   |
| `char`                                          | Character literal                                            | `pybind11/pybind11.h`   |
| `char16_t`                                      | UTF-16 character literal                                     | `pybind11/pybind11.h`   |
| `char32_t`                                      | UTF-32 character literal                                     | `pybind11/pybind11.h`   |
| `wchar_t`                                       | Wide character literal                                       | `pybind11/pybind11.h`   |
| `const char *`                                  | UTF-8 string literal                                         | `pybind11/pybind11.h`   |
| `const char16_t *`                              | UTF-16 string literal                                        | `pybind11/pybind11.h`   |
| `const char32_t *`                              | UTF-32 string literal                                        | `pybind11/pybind11.h`   |
| `const wchar_t *`                               | Wide string literal                                          | `pybind11/pybind11.h`   |
| `std::string`                                   | STL dynamic UTF-8 string                                     | `pybind11/pybind11.h`   |
| `std::u16string`                                | STL dynamic UTF-16 string                                    | `pybind11/pybind11.h`   |
| `std::u32string`                                | STL dynamic UTF-32 string                                    | `pybind11/pybind11.h`   |
| `std::wstring`                                  | STL dynamic wide string                                      | `pybind11/pybind11.h`   |
| `std::string_view`, `std::u16string_view`, etc. | STL C++17 string views                                       | `pybind11/pybind11.h`   |
| `std::pair<T1, T2>`                             | Pair of two custom types                                     | `pybind11/pybind11.h`   |
| `std::tuple<...>`                               | Arbitrary tuple of types                                     | `pybind11/pybind11.h`   |
| `std::reference_wrapper<...>`                   | Reference type wrapper                                       | `pybind11/pybind11.h`   |
| `std::complex<T>`                               | Complex numbers                                              | `pybind11/complex.h`    |
| `std::array<T, Size>`                           | STL static array                                             | `pybind11/stl.h`        |
| `std::vector<T>`                                | STL dynamic array                                            | `pybind11/stl.h`        |
| `std::deque<T>`                                 | STL double-ended queue                                       | `pybind11/stl.h`        |
| `std::valarray<T>`                              | STL value array                                              | `pybind11/stl.h`        |
| `std::list<T>`                                  | STL linked list                                              | `pybind11/stl.h`        |
| `std::map<T1, T2>`                              | STL ordered map                                              | `pybind11/stl.h`        |
| `std::unordered_map<T1, T2>`                    | STL unordered map                                            | `pybind11/stl.h`        |
| `std::set<T>`                                   | STL ordered set                                              | `pybind11/stl.h`        |
| `std::unordered_set<T>`                         | STL unordered set                                            | `pybind11/stl.h`        |
| `std::optional<T>`                              | STL optional type (C++17)                                    | `pybind11/stl.h`        |
| `std::experimental::optional<T>`                | STL optional type (exp.)                                     | `pybind11/stl.h`        |
| `std::variant<...>`                             | Type-safe union (C++17)                                      | `pybind11/stl.h`        |
| `std::filesystem::path<T>`                      | STL path (C++17) [1](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#id2) | `pybind11/stl.h`        |
| `std::function<...>`                            | STL polymorphic function                                     | `pybind11/functional.h` |
| `std::chrono::duration<...>`                    | STL time duration                                            | `pybind11/chrono.h`     |
| `std::chrono::time_point<...>`                  | STL date/time                                                | `pybind11/chrono.h`     |
| `Eigen::Matrix<...>`                            | Eigen: dense matrix                                          | `pybind11/eigen.h`      |
| `Eigen::Map<...>`                               | Eigen: mapped memory                                         | `pybind11/eigen.h`      |
| `Eigen::SparseMatrix<...>`                      | Eigen: sparse matrix                                         | `pybind11/eigen.h`      |

### 11.2 Strings, bytes and Unicode conversions

> Note: æœ¬èŠ‚è®¨è®ºçš„stringå¤„ç†åŸºäºPython3 stringsã€‚å¯¹äºpython2.7ï¼Œä½¿ç”¨`unicode`æ›¿æ¢`str`ï¼Œ`str`æ›¿æ¢`bytes`ã€‚Python2.7ç”¨äºæœ€å¥½ä½¿ç”¨`from __future__ import unicode_literals`é¿å…æ— æ„é—´ä½¿ç”¨`str`ä»£æ›¿`unicode`ã€‚

#### 11.2.1 ä¼ é€’Python stringsåˆ°C++

å½“å‘ä¸€ä¸ªæ¥æ”¶`std::string`æˆ–`char *`å‚æ•°çš„å‡½æ•°ä¼ é€’Pythonçš„`str`æ—¶ï¼Œpybind11ä¼šå°†Pythonå­—ç¬¦ä¸²ç¼–ç ä¸ºUTF-8ã€‚æ‰€æœ‰çš„Python `str`éƒ½èƒ½å¤Ÿç”¨UTF-8ç¼–ç ï¼Œæ‰€ä»¥è¿™ä¸ªæ“ä½œä¸ä¼šå¤±è´¥ã€‚

C++è¯­è¨€æ˜¯encoding agnosticã€‚ç¨‹åºå‘˜è´Ÿè´£å¤„ç†ç¼–ç ï¼Œæœ€ç®€å•çš„åšæ³•å°±æ˜¯æ¯å¤„éƒ½ä½¿ç”¨UTF-8ã€‚

```c++
m.def("utf8_test",
    [](const std::string &s) {
        cout << "utf-8 is icing on the cake.\n";
        cout << s;
    }
);
m.def("utf8_charptr",
    [](const char *s) {
        cout << "My favorite food is\n";
        cout << s;
    }
);
```

```python
>>> utf8_test("ğŸ‚")
utf-8 is icing on the cake.
ğŸ‚

>>> utf8_charptr("ğŸ•")
My favorite food is
ğŸ•
```

> Note: æœ‰äº›ç»ˆç«¯æ¨¡æ‹Ÿå™¨ä¸æ”¯æŒUTF-8æˆ–emojiå­—ä½“ï¼Œä¸Šé¢çš„ä¾‹å­å¯èƒ½æ— æ³•æ˜¾ç¤ºã€‚

æ— è®ºC++å‡½æ•°çš„å‚æ•°æ˜¯ä¼ å€¼æˆ–å¼•ç”¨ï¼Œæ˜¯å¦æ˜¯constï¼Œç»“æœéƒ½æ˜¯ä¸€æ ·çš„ã€‚

**å‘C++ä¼ é€’byteså¯¹è±¡**

å‘æ¥æ”¶`std::string`æˆ–`char *`ç±»å‹å‚æ•°çš„C++å‡½æ•°ä¼ é€’Python byteså¯¹è±¡æ— éœ€è½¬æ¢ã€‚åœ¨Python3ä¸Šï¼Œå¦‚æœæƒ³è¦å‡½æ•°åªæ¥æ”¶bytesï¼Œä¸æ¥æ”¶strï¼Œå¯ä»¥å£°æ˜å‚æ•°ç±»å‹ä¸º`py::bytes`ã€‚

#### 11.2.2 å‘Pythonè¿”å›C++ å­—ç¬¦ä¸²

å½“C++å‡½æ•°è¿”å›`std::string`æˆ–`char*`å‚æ•°ç»™Pythonè°ƒç”¨è€…æ—¶ï¼Œpybind11ä¼šå°†å­—ç¬¦ä¸²ä»¥UTF-8æ ¼å¼è§£ç ç»™åŸç”ŸPython strï¼Œç±»ä¼¼äºPythonä¸­çš„`bytes.decode('utf-8')`ã€‚å¦‚æœéšå¼è½¬æ¢å¤±è´¥ï¼Œpybind11å°†ä¼šæŠ›å‡ºå¼‚å¸¸`UnicodeDecodeError`ã€‚

```c++
m.def("std_string_return",
    []() {
        return std::string("This string needs to be UTF-8 encoded");
    }
);
```

```python
>>> isinstance(example.std_string_return(), str)
True
```

å› ä¸ºUTF-8åŒ…å«çº¯ASCIIï¼Œè¿”å›ä¸€ä¸ªçº¯ASCIIå­—ç¬¦ä¸²åˆ°Pythonæ²¡æœ‰ä»»ä½•é—®é¢˜ã€‚å¦åˆ™å°±éœ€è¦ç¡®ä¿ç¼–ç æ˜¯æœ‰æ•ˆçš„UTF-8ã€‚

> Warning: éšå¼è½¬æ¢å‡å®š`char *`å­—ç¬¦ä¸²ä»¥nullä¸ºç»“æŸç¬¦ã€‚è‹¥ä¸æ˜¯ï¼Œå°†å¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚

**æ˜¾å¼è½¬æ¢**

å¦‚æœC++ä»£ç æ„é€ äº†ä¸€ä¸ªéUTF-8çš„stringå­—ç¬¦ä¸²ï¼Œå¯ä»¥æ‰§è¡Œæ˜¾å¼è½¬æ¢å¹¶è¿”å›`py::str`å¯¹è±¡ã€‚æ˜¾å¼è½¬æ¢ä¸éšå¼è½¬æ¢çš„å¼€é”€ç›¸åŒã€‚

```c++
// This uses the Python C API to convert Latin-1 to Unicode
m.def("str_output",
    []() {
        std::string s = "Send your r\xe9sum\xe9 to Alice in HR"; // Latin-1
        py::str py_s = PyUnicode_DecodeLatin1(s.data(), s.length());
        return py_s;
    }
);
```

```python
>>> str_output()
'Send your rÃ©sumÃ© to Alice in HR'
```

 [Python C API](https://docs.python.org/3/c-api/unicode.html#built-in-codecs)æä¾›äº†ä¸€äº›å†…ç½®çš„ç¼–è§£ç æ–¹æ³•å¯ä»¥ä½¿ç”¨ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“å¦‚libiconv æ¥è½¬æ¢UTF-8ã€‚

**ä¸ä½¿ç”¨ç±»å‹è½¬æ¢æ¥è¿”å›C++å­—ç¬¦ä¸²**

å¦‚æœC++ `std::string`ä¸­çš„æ•°æ®ä¸è¡¨ç¤ºæ–‡æœ¬ï¼Œåˆ™åº”è¯¥ä»¥`bytes`çš„å½¢å¼ä¼ é€’ç»™Pythonï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥è¿”å›ä¸€ä¸ª`py::btyes`å¯¹è±¡ã€‚

```c++
m.def("return_bytes",
    []() {
        std::string s("\xba\xd0\xba\xd0");  // Not valid UTF-8
        return py::bytes(s);  // Return the data without transcoding
    }
);
```

```python
>>> example.return_bytes()
b'\xba\xd0\xba\xd0'
```

æ³¨æ„ï¼špybind11å¯ä»¥å°†bytesæ— éœ€ç¼–ç åœ°è½¬æ¢ä¸º`std::string`ï¼Œä½†ä¸èƒ½ä¸ç»ç¼–ç åœ°éšå¼è½¬æ¢`std::string`åˆ°bytesã€‚

```c++
m.def("asymmetry",
    [](std::string s) {  // Accepts str or bytes from Python
        return s;  // Looks harmless, but implicitly converts to str
    }
);
```

```python
>>> isinstance(example.asymmetry(b"have some bytes"), str)
True

>>> example.asymmetry(b"\xba\xd0\xba\xd0")  # invalid utf-8 as bytes
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xba in position 0: invalid start byte
```

#### 11.2.3 å®½å­—ç¬¦ä¸²

å‘å…¥å‚ä¸º`std::wstring`ã€`wchar_t*`ã€`std::u16string`æˆ–`std::u32string`çš„C++å‡½æ•°ä¼ é€’Python strå¯¹è±¡ï¼Œstrå°†è¢«ç¼–ç ä¸ºUTF-16æˆ–UTF-32ï¼ˆå…·ä½“å“ªç§å–å†³äºC++ç¼–è¯‘å™¨çš„æ”¯æŒï¼‰ã€‚å½“C++å‡½æ•°è¿”å›è¿™äº›ç±»å‹çš„å­—ç¬¦ä¸²åˆ°Python stræ—¶ï¼Œéœ€è¦ä¿è¯å­—ç¬¦ä¸²æ˜¯åˆæ³•çš„UTF-16æˆ–UTF-32ã€‚

```c++
#define UNICODE
#include <windows.h>

m.def("set_window_text",
    [](HWND hwnd, std::wstring s) {
        // Call SetWindowText with null-terminated UTF-16 string
        ::SetWindowText(hwnd, s.c_str());
    }
);
m.def("get_window_text",
    [](HWND hwnd) {
        const int buffer_size = ::GetWindowTextLength(hwnd) + 1;
        auto buffer = std::make_unique< wchar_t[] >(buffer_size);

        ::GetWindowText(hwnd, buffer.data(), buffer_size);

        std::wstring text(buffer.get());

        // wstring will be converted to Python str
        return text;
    }
);
```

> è­¦å‘Šï¼šå¸¦`--enable-unicode=ucs2`é€‰é¡¹ç¼–è¯‘çš„Python 2.7å’Œ3.3ç‰ˆæœ¬å¯èƒ½ä¸æ”¯æŒä¸Šè¿°çš„å®½å­—ç¬¦ä¸²ã€‚

å¤šå­—èŠ‚ç¼–ç åœ°å­—ç¬¦ä¸²ï¼Œå¦‚Shift-JISï¼Œå¿…é¡»è½¬æ¢ä¸ºUTF-8/16/32åï¼Œå†è¿”å›ç»™Pythonã€‚

#### 11.2.4 å­—ç¬¦ç±»å‹

å‘ä¸€ä¸ªå…¥å‚ä¸ºå­—ç¬¦ç±»å‹ï¼ˆchar, wchar_tï¼‰çš„C++å‡½æ•°ï¼Œä¼ é€’Python strï¼ŒC++å‡½æ•°å°†æ¥æ”¶strçš„é¦–å­—ç¬¦ã€‚å¦‚æœå­—ç¬¦ä¸²è¶…è¿‡ä¸€ä¸ªUnicodeå­—ç¬¦é•¿åº¦ï¼Œå°†å¿½ç•¥å°¾éƒ¨å­—èŠ‚ã€‚

å½“C++è¿”å›ä¸€ä¸ªå­—ç¬¦å˜é‡æ—¶ï¼Œå®ƒå°†è¢«è½¬åŒ–ä¸ºå•å­—ç¬¦çš„strå˜é‡ã€‚

```c++
m.def("pass_char", [](char c) { return c; });
m.def("pass_wchar", [](wchar_t w) { return w; });
```

```python
example.pass_char("A")
'A'
```

è™½ç„¶C++å¯ä»¥å°†æ•´æ•°è½¬æ¢ä¸ºå­—ç¬¦ç±»å‹ï¼ˆ`char c = 0x65`ï¼‰ï¼Œpybind11å¹¶ä¸ä¼šéšå¼è½¬æ¢Pythonæ•´æ•°åˆ°å­—ç¬¦ç±»å‹ã€‚å¯ä»¥ä½¿ç”¨`chr()`Pythonå‡½æ•°æ¥å°†æ•´æ•°è½¬æ¢ä¸ºå­—ç¬¦ã€‚

```python
>>> example.pass_char(0x65)
TypeError

>>> example.pass_char(chr(0x65))
'A'
```

å¦‚æœéœ€è¦ä½¿ç”¨8-bitæ•´æ•°ï¼Œå¯ä½¿ç”¨`int8_t`æˆ–`uint8_t`ä½œä¸ºå‚æ•°ç±»å‹ã€‚

#### 11.2.5 Grapheme clusters

A single grapheme may be represented by two or more Unicode characters. For example â€˜Ã©â€™ is usually represented as U+00E9 but can also be expressed as the combining character sequence U+0065 U+0301 (that is, the letter â€˜eâ€™ followed by a combining acute accent). The combining character will be lost if the two-character sequence is passed as an argument, even though it renders as a single grapheme.

```
>>> example.pass_wchar("Ã©")
'Ã©'

>>> combining_e_acute = "e" + "\u0301"

>>> combining_e_acute
'eÌ'

>>> combining_e_acute == "Ã©"
False

>>> example.pass_wchar(combining_e_acute)
'e'
```

Normalizing combining characters before passing the character literal to C++ may resolve *some* of these issues:

```
>>> example.pass_wchar(unicodedata.normalize("NFC", combining_e_acute))
'Ã©'
```

In some languages (Thai for example), there are [graphemes that cannot be expressed as a single Unicode code point](http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries), so there is no way to capture them in a C++ character type.

#### 11.2.6 c++17 string_view

C++17 string views are automatically supported when compiling in C++17 mode. They follow the same rules for encoding and decoding as the corresponding STL string type (for example, a `std::u16string_view` argument will be passed UTF-16-encoded data, and a returned `std::string_view` will be decoded as UTF-8).

### 11.3 STLå®¹å™¨

#### 11.3.1 è‡ªåŠ¨è½¬æ¢

åŒ…å«å¤´æ–‡ä»¶`pybind11/stl.h`åï¼Œè‡ªåŠ¨æ”¯æŒ `std::vector<>`/`std::deque<>`/`std::list<>`/`std::array<>`/`std::valarray<>`, `std::set<>`/`std::unordered_set<>`, å’Œ`std::map<>`/`std::unordered_map<>` åˆ°Python `list`, `set` å’Œ `dict` çš„ç±»å‹è½¬æ¢ã€‚ `std::pair<>` å’Œ`std::tuple<>` ç±»å‹è½¬æ¢åœ¨`pybind11/pybind11.h`ä¸­å·²ç»æ”¯æŒã€‚

éšå¼è½¬æ¢çš„ä¸»è¦ç¼ºç‚¹å°±æ˜¯Pythonå’ŒC++ä¹‹é—´çš„å®¹å™¨ç±»å‹è½¬æ¢éƒ½éœ€è¦æ‹·è´æ•°æ®ï¼Œè¿™å¯¹ç¨‹åºè¯­ä¹‰å’Œæ€§èƒ½æœ‰ä¸€å®šçš„å½±å“ã€‚åç»­ç« èŠ‚å°†ä»‹ç»å¦‚ä½•é¿å…è¯¥é—®é¢˜ã€‚

> Note: è¿™äº›ç±»å‹ä»»æ„åµŒå¥—éƒ½æ˜¯å¯ä»¥çš„ã€‚

#### 11.3.2 C++17åº“çš„å®¹å™¨

`pybind11/stl.h`æ”¯æŒC++17çš„ `std::optional<>` å’Œ`std::variant<>`ï¼ŒC++14çš„`std::experimental::optional<>`ã€‚

C++11ä¸­ä¹Ÿå­˜åœ¨è¿™äº›å®¹å™¨çš„å…¶ä»–ç‰ˆæœ¬ï¼Œå¦‚Boostä¸­ã€‚pybind11æä¾›äº†ä¸€ä¸ªç®€å•çš„æ–¹æ³•`type_caster`æ¥å¤„ç†è¿™äº›ç±»å‹ï¼š

```c++
// `boost::optional` as an example -- can be any `std::optional`-like container
namespace pybind11 { namespace detail {
    template <typename T>
    struct type_caster<boost::optional<T>> : optional_caster<boost::optional<T>> {};
}}
```

ä¸Šè¿°å†…å®¹åº”æ”¾åˆ°å¤´æ–‡ä»¶ä¸­ï¼Œå¹¶åœ¨éœ€è¦çš„åœ°æ–¹åŒ…å«å®ƒä»¬ã€‚Similarly, a specialization can be provided for custom variant types:

```c++
// `boost::variant` as an example -- can be any `std::variant`-like container
namespace pybind11 { namespace detail {
    template <typename... Ts>
    struct type_caster<boost::variant<Ts...>> : variant_caster<boost::variant<Ts...>> {};

    // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`
    template <>
    struct visit_helper<boost::variant> {
        template <typename... Args>
        static auto call(Args &&...args) -> decltype(boost::apply_visitor(args...)) {
            return boost::apply_visitor(args...);
        }
    };
}} // namespace pybind11::detail
```

The `visit_helper` specialization is not required if your `name::variant` provides a `name::visit()` function. For any other function name, the specialization must be included to tell pybind11 how to visit the variant.

> Warning: When converting a `variant` type, pybind11 follows the same rules as when determining which function overload to call ([Overload resolution order](https://pybind11.readthedocs.io/en/stable/advanced/functions.html#overload-resolution)), and so the same caveats hold. In particular, the order in which the `variant`â€™s alternatives are listed is important, since pybind11 will try conversions in this order. This means that, for example, when converting `variant<int, bool>`, the `bool` variant will never be selected, as any Python `bool` is already an `int` and is convertible to a C++ `int`. Changing the order of alternatives (and using `variant<bool, int>`, in this example) provides a solution.

#### 11.3.3 åˆ¶ä½œopaqueç±»å‹

pybind11ä¸¥é‡ä¾èµ–äºæ¨¡æ¿åŒ¹é…æœºåˆ¶æ¥è½¬æ¢STLç±»å‹çš„å‚æ•°å’Œè¿”å›å€¼ï¼Œå¦‚vectorï¼Œé“¾è¡¨ï¼Œå“ˆå¸Œè¡¨ç­‰ã€‚ç”šè‡³ä¼šé€’å½’å¤„ç†ï¼Œå¦‚lists of hash maps of pairs of elementary and custom typesã€‚

ç„¶è€Œï¼Œè¿™ä¸ªæ–¹æ³•çš„ä¸€ä¸ªåŸºæœ¬é™åˆ¶å°±æ˜¯ï¼ŒPythonå’ŒC++ç±»å‹çš„è½¬æ¢æ¶‰åŠåˆ°æ‹·è´æ“ä½œï¼Œè¿™å¦¨ç¢äº†pass-by-referenceçš„è¯­ä¹‰ã€‚

å‡è®¾æˆ‘ä»¬ç»‘å®šå¦‚ä¸‹å‡½æ•°ï¼š

```c++
void append_1(std::vector<int> &v) {
   v.push_back(1);
}
```

åœ¨Pythonä¸­è°ƒç”¨å®ƒï¼š

```python
>>> v = [5, 6]
>>> append_1(v)
>>> print(v)
[5, 6]
```

å¦‚ä½ æ‰€è§ï¼Œé€šè¿‡å¼•ç”¨ä¼ é€’STLæ•°æ®æ—¶ï¼Œä¿®æ”¹å¹¶ä¸ä¼šä¼ é€’åˆ°Pythonä¾§ã€‚ç›¸åŒçš„åœºæ™¯è¡¨ç°åœ¨é€šè¿‡`def_readwrite`æˆ–`def_readonly`å‡½æ•°å…¬å¼€STLæ•°æ®ç»“æ„æ—¶ï¼š

```c++
/* ... definition ... */

class MyClass {
    std::vector<int> contents;
};

/* ... binding code ... */

py::class_<MyClass>(m, "MyClass")
    .def(py::init<>())
    .def_readwrite("contents", &MyClass::contents);
```

è¿™ä¸ªä¾‹å­ä¸­ï¼Œå±æ€§å¯ä»¥æ•´ä½“çš„è¯»å†™ã€‚ä½†æ˜¯ï¼Œæ¶‰åŠåˆ°appendæ“ä½œæ—¶å°±æ— èƒ½ä¸ºåŠ›äº†ï¼š

```python
>>> m = MyClass()
>>> m.contents = [5, 6]
>>> print(m.contents)
[5, 6]
>>> m.contents.append(7)
>>> print(m.contents)
[5, 6]
```

æœ€åï¼Œåœ¨å¤„ç†å¤§å‹åˆ—è¡¨æ—¶ï¼Œæ¶‰åŠçš„æ‹·è´æ“ä½œä¼šè€—è´¹å·¨å¤§ã€‚ä¸ºå¤„ç†ä¸Šè¿°åœºæ™¯ï¼Œpybind11æä¾›äº†`PYBIND11_MAKE_OPAQUE(T)`æ¥ç¦ç”¨åŸºäºæ¨¡æ¿çš„ç±»å‹è½¬æ¢æœºåˆ¶ï¼Œä»è€Œä½¿ä»–ä»¬å˜å¾—ä¸é€æ˜ï¼ˆ*opaque*ï¼‰ã€‚opaqueå¯¹è±¡çš„å†…å®¹æ°¸è¿œä¸ä¼šè¢«æ£€æŸ¥æˆ–æå–ï¼Œå› æ­¤å®ƒä»¬å¯ä»¥é€šè¿‡å¼•ç”¨ä¼ é€’ã€‚ä¾‹å¦‚ï¼Œè¦å°†`std::vector<int>`è½¬æ¢ä¸ºopaqueç±»å‹ï¼Œéœ€è¦åœ¨æ‰€æœ‰ç»‘å®šä»£ç ä¹‹å‰æ·»åŠ å£°æ˜ï¼š

```c++
PYBIND11_MAKE_OPAQUE(std::vector<int>);
```

è¿™ä¸ªå®å¿…é¡»åœ¨é¡¶å±‚ï¼ˆæ‰€æœ‰å‘½åç©ºé—´å¤–ï¼‰è®¾å®šï¼Œå› ä¸ºç„¶æ·»åŠ äº†`type_caster`çš„æ¨¡æ¿å®ä¾‹åŒ–ã€‚å¦‚æœä½ ç»‘å®šä»£ç åŒ…å«å¤šä¸ªç¼–è¯‘å•å…ƒï¼Œéœ€è¦åœ¨æ¯ä¸ªæ–‡ä»¶ä½¿ç”¨`std::vector<int>`å‰æŒ‡å®šï¼ˆé€šå¸¸é€šè¿‡å…¬å…±çš„å¤´æ–‡ä»¶æ¥å®ç°ï¼‰ã€‚opaqueå¯¹è±¡æœ‰ç›¸å…³çš„`class_`å®šä¹‰æ¥è”ç³»Pythonä¸­çš„ç±»åï¼Œè¿˜éœ€å®šä¹‰ä¸€ç»„æœ‰ç”¨çš„æ“ä½œï¼Œå¦‚ï¼š

```c++
py::class_<std::vector<int>>(m, "IntVector")
    .def(py::init<>())
    .def("clear", &std::vector<int>::clear)
    .def("pop_back", &std::vector<int>::pop_back)
    .def("__len__", [](const std::vector<int> &v) { return v.size(); })
    .def("__iter__", [](std::vector<int> &v) {
       return py::make_iterator(v.begin(), v.end());
    }, py::keep_alive<0, 1>()) /* Keep vector alive while iterator is used */
    // ....
```

#### 11.3.4 ç»‘å®šSTLå®¹å™¨

å…¬å¼€STLå®¹å™¨ä½œä¸ºä¸€ä¸ªPythonå¯¹è±¡æ—¶ä¸€ä¸ªç›¸å½“å¸¸è§çš„éœ€æ±‚ï¼Œå› æ­¤pybind11ä¹Ÿæä¾›äº†ä¸€ä¸ªå¯é€‰çš„å¤´æ–‡ä»¶`pybind11/stl_bind.h`æ¥åšè¿™ä»¶äº‹ã€‚æ˜ å°„å®¹å™¨ä¼šå°½å¯èƒ½çš„å»åŒ¹é…Pythonå¯¹åº”ç±»å‹çš„è¡Œä¸ºã€‚ä¸‹é¢ç¤ºä¾‹å°†å±•ç¤ºè¯¥æœºåˆ¶çš„ä½¿ç”¨æ–¹æ³•ï¼š

```c++
// Don't forget this
#include <pybind11/stl_bind.h>

PYBIND11_MAKE_OPAQUE(std::vector<int>);
PYBIND11_MAKE_OPAQUE(std::map<std::string, double>);

// ...

// later in binding code:
py::bind_vector<std::vector<int>>(m, "VectorInt");
py::bind_map<std::map<std::string, double>>(m, "MapStringDouble");
```

ç»‘å®šSTLå®¹å™¨æ—¶ï¼Œpybind11ä¼šæ ¹æ®å®¹å™¨å…ƒç´ çš„ç±»å‹æ¥å†³å®šè¯¥å®¹å™¨æ˜¯å¦åº”è¯¥å±€é™äºæ¨¡å—å†…ï¼ˆå‚è€ƒModule-local class bindingsç‰¹æ€§ï¼‰ã€‚å¦‚æœå®¹å™¨å…ƒç´ çš„ç±»å‹ä¸æ˜¯å·²ç»ç»‘å®šçš„è‡ªå®šä¹‰ç±»å‹ä¸”æœªæ ‡è¯†`py::module_local`ï¼Œé‚£ä¹ˆå®¹å™¨ç»‘å®šå°†åº”ç”¨`py::module_local`ã€‚è¿™åŒ…æ‹¬æ•°å€¼ç±»å‹ã€stringsã€Eigenç±»å‹ï¼Œå’Œå…¶ä»–åœ¨ç»‘å®šSTLå®¹å™¨æ—¶è¿˜æœªç»‘å®šçš„ç±»å‹ã€‚module-localç»‘å®šçš„æ„å›¾æ˜¯ä¸ºäº†é¿å…æ¨¡å—é—´çš„æ½œåœ¨çš„å†²çªï¼ˆå¦‚ï¼Œä¸¤ä¸ªç‹¬ç«‹çš„æ¨¡å—éƒ½è¯•å›¾ç»‘å®š`std::vector<int>`ï¼‰ã€‚

é€šè¿‡æŒ‡å®šå±æ€§`py::module_local()`æˆ–`py_module_local(false)`ï¼Œä½ ä¹Ÿå¯ä»¥å¼ºåˆ¶ç»‘å®šçš„STLå®¹å™¨å…¬å¼€åœ¨æ¨¡å—å†…æˆ–å…¨å±€ï¼š

```c++
py::bind_vector<std::vector<int>>(m, "VectorInt", py::module_local(false));
```

æ³¨æ„ï¼šè¿™æ ·çš„å…¨å±€ç»‘å®šå¯èƒ½ä¼šå¯¼è‡´æ¨¡å—æ— æ³•åŠ è½½ï¼Œå¦‚æœå…¶ä»–çš„æ¨¡å—ä¹Ÿç»‘å®šäº†ç›¸åŒçš„å®¹å™¨ç±»å‹ï¼ˆå¦‚`std::vector<int>`ï¼‰å¹¶ä»¥åŠ è½½ã€‚

### 11.4 å‡½æ•°å¯¹è±¡

è¦ä½¿èƒ½ä»¥ä¸‹å±æ€§ï¼Œéœ€è¦åŒ…å«`pybind11/functional.h`ã€‚

**å›è°ƒå¹¶ä¼ é€’åŒ¿åå‡½æ•°**

C++11æ ‡å‡†å¼•å…¥äº†åŠŸèƒ½å¼ºå¤§çš„lambdaå‡½æ•°å’Œæ³›å‡½å¯¹è±¡`std::function<>`ã€‚lambdaå‡½æ•°æœ‰ä¸¤ç§ç±»å‹ï¼šæ— çŠ¶æ€lambdaå‡½æ•°ç±»ä¼¼äºæŒ‡å‘ä¸€å—åŒ¿åä»£ç çš„å‡½æ•°æŒ‡é’ˆï¼Œè€Œæœ‰çŠ¶æ€lambdaå‡½æ•°è¿˜ä¾èµ–äºå­˜å‚¨åœ¨lambdaé—­åŒ…å¯¹è±¡ä¸­çš„è¢«æ•è·çš„å‚æ•°ã€‚

è¿™é‡Œæœ‰ä¸€ä¸ªæ¥æ”¶ä»»æ„å‡½æ•°ç­¾åä¸º`int -> int`çš„å‡½æ•°ç±»å‹å‚æ•°ï¼ˆæœ‰çŠ¶æ€æˆ–æ— çŠ¶æ€ï¼‰ï¼š

```c++
int func_arg(const std::function<int(int)> &f) {
    return f(10);
}
```

ä¸‹é¢çš„ä¾‹å­æ›´å¤æ‚ï¼Œå®ƒçš„å…¥å‚æ˜¯ä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒæ ·ç±»å‹çš„å‡½æ•°å¯¹è±¡ã€‚è¿”å›å€¼æ˜¯ä¸€ä¸ªæœ‰çŠ¶æ€çš„lambdaå‡½æ•°ï¼Œå®ƒæ•è·äº†`f`å‚æ•°ï¼š

```c++
std::function<int(int)> func_ret(const std::function<int(int)> &f) {
    return [f](int i) {
        return f(i) + 1;
    };
}
```

åœ¨C++å›è°ƒå‡½æ•°ä¸­ä½¿ç”¨pythonå…·åå‚æ•°ï¼Œéœ€è¦ä½¿ç”¨`py::cpp_function`åŒ…è£¹ï¼Œç±»ä¼¼äºä¸‹é¢çš„ä»£ç ï¼š

```c++
py::cpp_function func_cpp() {
    return py::cpp_function([](int i) { return i+1; },
       py::arg("number"));
}
```

åŒ…å«`pybind11/functional.h`å¤´æ–‡ä»¶åï¼Œå¯ä»¥ç®€å•åœ°ç›´æ¥ä¸ºä¸Šè¿°å‡½æ•°ç”Ÿæˆç»‘å®šä»£ç ï¼š

```c++
#include <pybind11/functional.h>

PYBIND11_MODULE(example, m) {
    m.def("func_arg", &func_arg);
    m.def("func_ret", &func_ret);
    m.def("func_cpp", &func_cpp);
}
```

Pythonä¸­äº¤äº’ç¤ºä¾‹å¦‚ä¸‹ï¼š

```python
$ python
>>> import example
>>> def square(i):
...     return i * i
...
>>> example.func_arg(square)
100L
>>> square_plus_1 = example.func_ret(square)
>>> square_plus_1(4)
17L
>>> plus_1 = func_cpp()
>>> plus_1(number=43)
44L
```

> Warning
>
> è¯·è®°ä½åœ¨ä»C++ä¼ é€’å‡½æ•°å¯¹è±¡åˆ°Pythonçš„è¿‡ç¨‹ä¸­ï¼ˆåå‘äº¦ç„¶ï¼‰ï¼Œå°†ç”Ÿæˆä¸€äº›åŒ…è£…ä»£ç æ¥ä¸¤ç§è¯­è¨€çš„å‡½æ•°è°ƒç”¨ã€‚è¿™ç§ç¿»è¯‘è‡ªç„¶ä¼šç¨å¾®å¢åŠ å‡½æ•°è°ƒç”¨çš„å¼€é”€ã€‚å½“ä¸€ä¸ªå‡½æ•°åœ¨Pythonå’ŒC++ä¹‹é—´æ¥å›æ‹·è´å¤šæ¬¡æ—¶ï¼ŒåŒ…è£…å±‚æ•°ä¼šä¸æ–­ç´¯ç§¯ï¼Œä¼šæ˜æ˜¾é™ä½æ€§èƒ½ã€‚
>
> è¿™é‡Œæœ‰ä¸ªä¾‹å¤–ï¼šä¸€ä¸ªæ— çŠ¶æ€å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’ç»™åœ¨Pythonä¸­å…¬å¼€çš„å¦ä¸€ä¸ªC++å‡½æ•°æ—¶ï¼Œå°†ä¸ä¼šæœ‰é¢å¤–çš„å¼€é”€ã€‚Pybind11å°†ä»å°è£…çš„å‡½æ•°ä¸­æå–C++å‡½æ•°æŒ‡é’ˆï¼Œä»¥å›é¿æ½œåœ¨åœ°C++ -> Python -> C++çš„å¾€è¿”ã€‚

### 11.5 Chrono

åŒ…å«`pybind11/chrono`å°†ä½¿èƒ½C++11 chronoå’ŒPython datatimeå¯¹è±¡å°†çš„è‡ªåŠ¨è½¬æ¢ï¼Œè¿˜æ”¯æŒpython floatsï¼ˆä»`time.monotonic()`æˆ–`time.perf_counter()`è·å–çš„ï¼‰å’Œ`time.process_time()`åˆ°durationsçš„è½¬æ¢ã€‚

#### 11.5.1 C++11æ—¶é’Ÿçš„æ¦‚è§ˆ

ä½¿ç”¨è¿™äº›è½¬æ¢æ—¶å®¹æ˜“æ··æ·†çš„ç‚¹æ˜¯ï¼ŒC++11ä¸­æä¾›çš„å„ç§æ—¶é’Ÿçš„å·®å¼‚ã€‚C++11æ ‡å‡†å®šä¹‰äº†ä¸‰ç§æ—¶é’Ÿç±»å‹ï¼Œç”¨æˆ·ä¹Ÿå¯ä»¥æ ¹æ®è‡ªèº«éœ€æ±‚å®šä¹‰è‡ªå·±çš„æ—¶é’Ÿç±»å‹ã€‚è¿™äº›æ—¶é’Ÿæœ‰ç€ä¸ç”¨çš„å±æ€§ï¼Œä¸Pythonä¹‹é—´è½¬æ¢æ—¶ä¹Ÿä¼šè·å¾—ä¸åŒçš„ç»“æœã€‚

æ ‡å‡†å®šä¹‰çš„ç¬¬ä¸€ç§æ—¶é’Ÿ`std::chrono::system_clock`ã€‚å®ƒæµ‹é‡å½“å‰çš„æ—¶é—´å’Œæ—¥æœŸã€‚ä½†æ˜¯ï¼Œè¿™ä¸ªæ—¶é’Ÿä¼šéšç€æ“ä½œç³»ç»Ÿçš„æ—¶é’Ÿå˜åŒ–è€Œæ”¹å˜ã€‚ä¾‹å¦‚ï¼Œåœ¨ç³»ç»Ÿæ—¶é—´ä¸æ—¶é—´æœåŠ¡å™¨åŒæ­¥æ—¶ï¼Œè¿™ä¸ªæ—¶é’Ÿä¹Ÿä¼šè·Ÿç€æ”¹å˜ã€‚è¿™å¯¹è®¡æ—¶åŠŸèƒ½æ¥è¯´å¾ˆç³Ÿç³•ï¼Œä½†å¯¹æµ‹é‡wall timeè¿˜æ˜¯æœ‰ç”¨çš„ã€‚

æ ‡å‡†å®šä¹‰çš„ç¬¬äºŒç§æ—¶é’Ÿ`std::chrono::steady_clock`ã€‚è¿™ä¸ªæ—¶é’Ÿä»¥ç¨³å®šçš„é€Ÿåº¦è·³åŠ¨ï¼Œä»ä¸è°ƒæ•´ã€‚è¿™éå¸¸å®ç”¨äºè®¡æ—¶åŠŸèƒ½ï¼Œä½†ä¸å®é™…æ—¶é—´å’Œæ—¥å¿—å¹¶ä¸ä¸€è‡´ã€‚è¿™ä¸ªæ—¶é—´é€šå¸¸æ˜¯ä½ æ“ä½œç³»ç»Ÿå·²ç»è¿è¡Œçš„æ—¶é—´ï¼Œè™½ç„¶ä¸æ˜¯å¿…é¡»çš„ã€‚è¿™ä¸ªæ—¶é’Ÿæ°¸è¿œä¸ä¼šä¸ç³»ç»Ÿæ—¶é’Ÿç›¸åŒï¼Œå› ä¸ºç³»ç»Ÿæ—¶é’Ÿå¯ä»¥æ”¹å˜ï¼Œä½†steady_clockä¸èƒ½ã€‚

æ ‡å‡†å®šä¹‰çš„ç¬¬äºŒç§æ—¶é’Ÿ`std::chrono::high_resolution_clock`ã€‚å®ƒæ˜¯ç³»ç»Ÿä¸­åˆ†è¾¨ç‡æœ€é«˜çš„æ—¶é’Ÿï¼Œé€šå¸¸æ˜¯system clock æˆ– steady clockçš„ä¸€ç§ï¼Œä¹Ÿå¯ä»¥æœ‰è‡ªå·±ç‹¬ç«‹çš„æ—¶é’Ÿã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½ åœ¨Pythonä¸­è·å–åˆ°çš„è¯¥æ—¶é’Ÿçš„è½¬æ¢å€¼ï¼Œå¯èƒ½å­˜åœ¨å·®å¼‚ï¼Œè¿™å–å†³äºç³»ç»Ÿçš„å®ç°ã€‚å¦‚æœå®ƒæ˜¯ç³»ç»Ÿæ—¶é’Ÿçš„ä¸€ç§ï¼ŒPythonå°†å¾—åˆ°datetimeå¯¹è±¡ï¼Œå¦åˆ™å°†å¾—åˆ°timedeltaå¯¹è±¡ã€‚

#### 11.5.2 æä¾›çš„è½¬æ¢

**C++åˆ°Python**

- `std::chrono::system_clock::time_point` â†’ `datetime.datetime`
- `std::chrono::duration` â†’ `datetime.timedelta`
- `std::chrono::[other_clocks]::time_point` â†’ `datetime.timedelta`

**Pythonåˆ°C++**

- `datetime.datetime`or`datetime.date`or`datetime.time` â†’ `std::chrono::system_clock::time_point`
- `datetime.timedelta` â†’ `std::chrono::duration`
- `datetime.timedelta` â†’ `std::chrono::[other_clocks]::time_point`
- `float` â†’ `std::chrono::duration`
- `float` â†’ `std::chrono::[other_clocks]::time_point`

### 11.6 Eigen

æ²¡æ¥è§¦è¿‡Eigenï¼Œå…ˆä¸ç¿»è¯‘ã€‚

### 11.7 è‡ªå®šä¹‰ç±»å‹è½¬æ¢

åœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œç¨‹åºå¯èƒ½éœ€è¦ä¸€äº›pybind11æ²¡æœ‰æä¾›çš„è‡ªå®šä¹‰ç±»å‹è½¬æ¢ï¼Œè¿™éœ€è¦ä½¿ç”¨åˆ°åŸå§‹çš„Python C APIã€‚è¿™æ˜¯ç›¸å½“é«˜çº§çš„ä½¿ç”¨æ–¹æ³•ï¼Œåªæœ‰ç†Ÿæ‚‰Pythonå¼•ç”¨è®¡æ•°å¤æ‚ä¹‹å¤„çš„ä¸“å®¶æ‰èƒ½ä½¿ç”¨ã€‚

The following snippets demonstrate how this works for a very simple `inty` type that that should be convertible from Python types that provide a `__int__(self)` method.

```c++
struct inty { long long_value; };

void print(inty s) {
    std::cout << s.long_value << std::endl;
}
```

The following Python snippet demonstrates the intended usage from the Python side:

```python
class A:
    def __int__(self):
        return 123


from example import print

print(A())
```

To register the necessary conversion routines, it is necessary to add an instantiation of the `pybind11::detail::type_caster<T>` template. Although this is an implementation detail, adding an instantiation of this type is explicitly allowed.

```c++
namespace pybind11 { namespace detail {
    template <> struct type_caster<inty> {
    public:
        /**
         * This macro establishes the name 'inty' in
         * function signatures and declares a local variable
         * 'value' of type inty
         */
        PYBIND11_TYPE_CASTER(inty, _("inty"));

        /**
         * Conversion part 1 (Python->C++): convert a PyObject into a inty
         * instance or return false upon failure. The second argument
         * indicates whether implicit conversions should be applied.
         */
        bool load(handle src, bool) {
            /* Extract PyObject from handle */
            PyObject *source = src.ptr();
            /* Try converting into a Python integer value */
            PyObject *tmp = PyNumber_Long(source);
            if (!tmp)
                return false;
            /* Now try to convert into a C++ int */
            value.long_value = PyLong_AsLong(tmp);
            Py_DECREF(tmp);
            /* Ensure return code was OK (to avoid out-of-range errors etc) */
            return !(value.long_value == -1 && !PyErr_Occurred());
        }

        /**
         * Conversion part 2 (C++ -> Python): convert an inty instance into
         * a Python object. The second and third arguments are used to
         * indicate the return value policy and parent object (for
         * ``return_value_policy::reference_internal``) and are generally
         * ignored by implicit casters.
         */
        static handle cast(inty src, return_value_policy /* policy */, handle /* parent */) {
            return PyLong_FromLong(src.long_value);
        }
    };
}} // namespace pybind11::detail
```

> Note: A `type_caster<T>` defined with `PYBIND11_TYPE_CASTER(T, ...)` requires that `T` is default-constructible (`value` is first default constructed and then `load()` assigns to it).

> Warning: When using custom type casters, itâ€™s important to declare them consistently in every compilation unit of the Python extension module. Otherwise, undefined behavior can ensue.







