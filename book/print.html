<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>pybind11 Chinese docs</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="00.介绍.html">简介</a></li><li class="chapter-item expanded "><a href="01.改动日志.html"><strong aria-hidden="true">1.</strong> 改动日志</a></li><li class="chapter-item expanded "><a href="02.更新指南.html"><strong aria-hidden="true">2.</strong> 更新指南</a></li><li class="chapter-item expanded "><a href="03.安装说明.html"><strong aria-hidden="true">3.</strong> 安装说明</a></li><li class="chapter-item expanded "><a href="04.首次尝试.html"><strong aria-hidden="true">4.</strong> 首次尝试</a></li><li class="chapter-item expanded "><a href="05.面对对象编程.html"><strong aria-hidden="true">5.</strong> 面对对象编程</a></li><li class="chapter-item expanded "><a href="06.构建系统.html"><strong aria-hidden="true">6.</strong> 构建系统</a></li><li class="chapter-item expanded "><a href="07.函数.html"><strong aria-hidden="true">7.</strong> 函数</a></li><li class="chapter-item expanded "><a href="08.类.html"><strong aria-hidden="true">8.</strong> 类</a></li><li class="chapter-item expanded "><a href="09.异常.html"><strong aria-hidden="true">9.</strong> 异常</a></li><li class="chapter-item expanded "><a href="10.智能指针.html"><strong aria-hidden="true">10.</strong> 智能指针</a></li><li class="chapter-item expanded "><a href="11.类型转换.html"><strong aria-hidden="true">11.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="12.Python的C++接口.html"><strong aria-hidden="true">12.</strong> Python的C++接口</a></li><li class="chapter-item expanded "><a href="13.内嵌解释器.html"><strong aria-hidden="true">13.</strong> 内嵌解释器</a></li><li class="chapter-item expanded "><a href="14.杂项.html"><strong aria-hidden="true">14.</strong> 杂项</a></li><li class="chapter-item expanded "><a href="15.FAQ.html"><strong aria-hidden="true">15.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">pybind11 Chinese docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="pybind11无缝连接c11和python"><a class="header" href="#pybind11无缝连接c11和python">pybind11——无缝连接C+11和Python</a></h2>
<p>pybind11是一个只有头文件的轻量级库，它在导出C++类型到Python的同时，也导出Python类型到C++中，其主要目的是建立现有C++代码的Python绑定。它与David Abrahams的Boost.Python库目的和语法相似，都是通过编译期内省来推断类型信息，以最大程度地降低传统扩展模块中的重复样板代码。</p>
<p>Boost.Python的问题主要在于Boost本身，这也是我创建一个类似项目的原因。Boost是一套庞大且复杂的工具库，它几乎兼容所有的C++编译器。但这种兼容性是有成本的：为了支持那些极其古老且充满BUG的编译器版本，Boost不得不使用各种晦涩难懂的模板技巧与变通方法。现在，支持C++11的编译器已经被广泛使用，这种沉重结构已成为一种过大且不必要的依赖。</p>
<p>你可以把pybind11库想象成Boost.Python的一个小型独立版本，其中所有与python绑定生成无关的内容都被删除了。不算注释，pybind11核心头文件大约只有4K行代码，并且它只依赖于Python（2.7或3.5+，或PyPy）和C ++标准库。由于C++11语言的新特性(特别是元组、lambda函数和可变参数模板），这种紧凑的实现才成为可能。自创建以来，这个库已经在很多方面超越了Boost.Python，多数常见情况下pybind11使得python绑定代码变得非常简单。</p>
<h3 id="11-核心特性"><a class="header" href="#11-核心特性">1.1 核心特性</a></h3>
<p>pybind11可以将以下C++核心特性映射到Python：</p>
<ul>
<li>函数入参和返回值可以是自定义数据结构的值、引用或者指针；</li>
<li>类成员方法和静态方法；</li>
<li>重载函数；</li>
<li>类成员变量和静态变量；</li>
<li>任意异常类型；</li>
<li>枚举；</li>
<li>回调函数；</li>
<li>迭代器和ranges；</li>
<li>自定义操作符；</li>
<li>单继承和多重继承；</li>
<li>STL数据结构；</li>
<li>智能指针；</li>
<li>Internal references with correct reference counting；</li>
<li>可以在Python中扩展带虚函数（和纯虚函数）的C++类；</li>
</ul>
<h3 id="12-好用的功能"><a class="header" href="#12-好用的功能">1.2 好用的功能</a></h3>
<p>除了上述核心功能外，pybind11还提供了一些好用的功能：</p>
<ul>
<li>支持Python2.7, 3.5+, PyPy/PyPy3 7.3与实现无关的接口。</li>
<li>可以绑定带捕获参数的lambda函数，lambda捕获的数据存储生成的Python函数对象中。</li>
<li>pybind11使用C++11移动构造函数和移动运算符，尽可能有效的转换自定义数据类型。(pybind11 uses C++11 move constructors and move assignment operators whenever possible to efficiently transfer custom data types.)</li>
<li>通过Python的buffer协议，可以很轻松地获取自定义类型的内存指针。这样，我们可以很方便地在C++矩阵类型（如Eigen）和NumPy之间快速转换，而无需昂贵的拷贝操作。</li>
<li>pybind11可以自动将函数矢量化，以便它们透明地应用于以NumPy数组为参数的所有条目。</li>
<li>只需几行代码就可以支持Python基于切片的访问和赋值操作。</li>
<li>使用时只需要包含几个头文件即可，不用链接任何其他的库。</li>
<li>相比Boost.Python，生成的库文件更小，编译更快。</li>
<li>使用<code>constexpr</code>在编译器与计算函数签名，进一步减小了库文件大小。</li>
<li>可以轻松地让C++类型支持Python pickle和unpickle操作。</li>
</ul>
<h3 id="13-支持的编译器"><a class="header" href="#13-支持的编译器">1.3 支持的编译器</a></h3>
<ol>
<li>Clang/LLVM 3.3以上 (Apple Xcode’s clang需要5.0.0以上版本)</li>
<li>GCC 4.8以上</li>
<li>Microsoft Visual Studio 2015 Update 3以上</li>
<li>Intel classic C++ compiler 18 or newer (ICC 20.2 tested in CI)</li>
<li>Cygwin/GCC (previously tested on 2.5.1)</li>
<li>NVCC (CUDA 11.0 tested in CI)</li>
<li>NVIDIA PGI (20.9 tested in CI)</li>
</ol>
<h3 id="14-关于"><a class="header" href="#14-关于">1.4 关于</a></h3>
<p>This project was created by Wenzel Jakob. Significant features and/or improvements to the code were contributed by Jonas Adler, Lori A. Burns, Sylvain Corlay, Eric Cousineau, Aaron Gokaslan, Ralf Grosse-Kunstleve, Trent Houliston, Axel Huebl, @hulucc, Yannick Jadoul, Sergey Lyskov Johan Mabille, Tomasz Miąsko, Dean Moldovan, Ben Pritchard, Jason Rhinelander, Boris Schäling, Pim Schellart, Henry Schreiner, Ivan Smirnov, Boris Staletic, and Patrick Stewart.</p>
<p>We thank Google for a generous financial contribution to the continuous integration infrastructure used by this project.</p>
<h3 id="15-贡献"><a class="header" href="#15-贡献">1.5 贡献</a></h3>
<p>See the <a href="https://github.com/pybind/pybind11/blob/master/.github/CONTRIBUTING.md">contributing guide</a> for information on building and contributing to pybind11.</p>
<h3 id="16-license"><a class="header" href="#16-license">1.6 License</a></h3>
<p>pybind11 is provided under a BSD-style license that can be found in the <a href="https://github.com/pybind/pybind11/blob/master/LICENSE">LICENSE</a> file. By using, distributing, or contributing to this project, you agree to the terms and conditions of this license.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="改动日志"><a class="header" href="#改动日志">改动日志</a></h2>
<p>主要介绍了各个发布版本增加的功能、改进点，以及修复的BUG。暂时不翻译吧，有兴趣的可以看官方文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="更新指南"><a class="header" href="#更新指南">更新指南</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="3-安装说明"><a class="header" href="#3-安装说明">3. 安装说明</a></h2>
<p>我们可以在<a href="https://github.com/pybind/pybind11">pybind/pybind11 on GitHub</a>获取到pybind11的源码。推荐pybind11开发者使用下面介绍的前三种方法之一，来获取pybind11。</p>
<h3 id="31-以子模块的形式集成"><a class="header" href="#31-以子模块的形式集成">3.1 以子模块的形式集成</a></h3>
<p>当你的项目使用Git管理时，你可以将pybind11当做一个子模块嵌入到你的项目中。在你的git仓库，使用以下命令即可包含pybind11：</p>
<pre><code class="language-sh">git submodule add -b stable ../../pybind/pybind11 extern/pybind11
git submodule update --init
</code></pre>
<p>这里假设你将项目的依赖放在了<code>extern</code>目录下，并且使用GitHub。如果你没有使用GitHub，可以使用完整的https或ssh URL来代替上面的相对URL<code>../../pybind/pybind11</code>。一些服务器可能需要<code>.git</code>扩展（GitHub不用）。</p>
<p>到这一步后，你可以直接include <code>extern/pybind11/include</code>目录即可。或者，你可以使用各种集成工具（见Build System一章)来包含pybind11。</p>
<h3 id="32-通过pypi来集成"><a class="header" href="#32-通过pypi来集成">3.2 通过PyPI来集成</a></h3>
<p>你可以使用pip，通过PyPI来下载Pybind11的Python包，里面包含了源码已经CMake文件。像这样：</p>
<pre><code class="language-sh">pip install pybind11
</code></pre>
<p>这样pybind11将以标准的Python包的形式提供。如果你想在root环境下直接使用pybind11，可以这样做：</p>
<pre><code class="language-sh">pip install &quot;pybind11[global]&quot;
</code></pre>
<p>如果你使用系统自带的Python来安装，我们推荐在root环境下安装。这样会在<code>/usr/local/include/pybind11</code> 和 <code>/usr/local/share/cmake/pybind11</code>添加文件，除非你想这样。还是推荐你只在虚拟环境或你的<code>pyproject.toml</code>中使用。</p>
<h3 id="33-通过conda-forge集成"><a class="header" href="#33-通过conda-forge集成">3.3 通过conda-forge集成</a></h3>
<p>You can use pybind11 with conda packaging via <a href="https://github.com/conda-forge/pybind11-feedstock">conda-forge</a>:</p>
<pre><code class="language-sh">conda install -c conda-forge pybind11
</code></pre>
<h3 id="34-通过vcpkg集成"><a class="header" href="#34-通过vcpkg集成">3.4 通过vcpkg集成</a></h3>
<p>你可以通过Microsoft <a href="https://github.com/Microsoft/vcpkg/">vcpkg</a>依赖管理工具来下载和安装pybind11：</p>
<pre><code>git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh
./vcpkg integrate install
vcpkg install pybind11
</code></pre>
<h3 id="35-通过brew全局安装"><a class="header" href="#35-通过brew全局安装">3.5 通过brew全局安装</a></h3>
<p>brew包管理（Homebrew on macOS, or Linuxbrew on Linux）有pybind11包。这样安装：</p>
<pre><code class="language-sh">brew install pybind11
</code></pre>
<h3 id="36-其他方法"><a class="header" href="#36-其他方法">3.6 其他方法</a></h3>
<p>Other locations you can find pybind11 are <a href="https://repology.org/project/python:pybind11/versions">listed here</a>; these are maintained by various packagers and the community.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="4-首次尝试first-steps"><a class="header" href="#4-首次尝试first-steps">4. 首次尝试（First steps）</a></h2>
<p>本章将演示pybind11的基本特性。在开始前，请确保正确配置了编译pybind11测试用例的开发环境。</p>
<h3 id="41-编译测试用例"><a class="header" href="#41-编译测试用例">4.1 编译测试用例</a></h3>
<h4 id="linuxmacos"><a class="header" href="#linuxmacos">Linux/macOS</a></h4>
<p>在Linux上，你需要安装python-dev或python3-dev包和cmake。在macOS上，系统自带了所需的python版本，还需要安装cmake。</p>
<p>在安装好依赖项之后，运行下面的脚本：</p>
<pre><code class="language-sh">mkdir build
cd build
cmake ..
make check -j 4
</code></pre>
<p>脚本的最后一行将编译并运行测试用例。</p>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>在Windows上，需要支持C++11的Visual Studio版本（15及其以上）。</p>
<blockquote>
<p>Note：在Visual Studio 2017(MSVC 14.1)上使用C++17时，pybind11需要添加标识<code>/permissive-</code>来让编译器强制标准一致。在Visual Studio 2019上，不做强制要求，但同样建议添加。</p>
</blockquote>
<p>使用以下命令编译和运行测试用例：</p>
<pre><code class="language-sh">mkdir build
cd build
cmake ..
cmake --build . --config Release --target check
</code></pre>
<p>命令将在命令行创建Visual Studio工程，编译并运行项目。</p>
<blockquote>
<p>Note：如果测试失败了，请确保Python程序和测试用例是由同一类型处理器（如i386或x86_64）编译的。你可以指定x86_64为目标架构来生成vs工程，命令像这样<code>cmake -A x64 ..</code>。</p>
</blockquote>
<h3 id="42-头文件和命名空间约定"><a class="header" href="#42-头文件和命名空间约定">4.2 头文件和命名空间约定</a></h3>
<p>为简洁起见，所有代码示例都假定存在以下两行：</p>
<pre><code class="language-c++">#include &lt;pybind11/pybind11.h&gt;
namespace py = pybind11;
</code></pre>
<p>某些功能可能需要其他头文件，但会根据需要指定。</p>
<h3 id="43-为简单函数创建绑定"><a class="header" href="#43-为简单函数创建绑定">4.3 为简单函数创建绑定</a></h3>
<p>我们将从绑定一个简单的加法函数来演示pybind11的使用。</p>
<pre><code class="language-c++">int add(int i, int j) {
    return i + j;
}
</code></pre>
<p>简单起见，我们将加法函数和绑定代码都放到<code>example.cpp</code>文件中，内容如下：</p>
<pre><code class="language-c++">#include &lt;pybind11/pybind11.h&gt;

int add(int i, int j) {
    return i + j;
}

PYBIND11_MODULE(example, m) {
    m.doc() = &quot;pybind11 example plugin&quot;; // optional module docstring
    m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two numbers&quot;);
}
</code></pre>
<p><code>PYBIND11_MODULE</code>会创建一个函数，它在Python中使用<code>import</code>语句时被调用。宏的第一个参数是模块名（example），不使用引号包住；第二个参数是类型为<code>py::module_</code>的变量（m），它是创建绑定的主要接口。<code>module_::def()</code>方法，则会生成add函数的Python绑定代码。</p>
<blockquote>
<p>Note：我们只需要少量的代码就可以将函数暴露给Python，函数入参和返回值相关的细节都由模板元编程自动推断。这种方式和语法是借用Boost.Python的，尽管底层实现完全不同。</p>
</blockquote>
<p>pybind11是一个head-only库，它不需要链接任何库，也没有魔法般的中间转换步骤。在Linux上，示例可以使用下面的命令进行编译：</p>
<pre><code class="language-sh">c++ -O3 -Wall -shared -std=c++11 -fPIC $(python3 -m pybind11 --includes) example.cpp -o example$(python3-config --extension-suffix)
</code></pre>
<blockquote>
<p>Note：如果你使用子模块的方式包含pybind11代码，这里需要使用<code>$(python3-config --includes) -Iextern/pybind11/include</code>代替<code>$(python3 -m pybind11 --includes)</code>。原因在后续章节会解释。</p>
</blockquote>
<p>如果需要更多有关于Linux和MacOS上所需编译标志的详细信息，请参阅手动构建章节。有关完整的跨平台编译说明，请参阅构建系统章节。</p>
<p>编译上面的C++代码后，我们会得到一个二进制模块文件，直接使用<code>import</code>导入模块到Python中。假设编译好的模块位于当前目录下，Python交互示例代码如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; import example
&gt;&gt;&gt; example.add(1, 2)
3L
&gt;&gt;&gt; 
</code></pre>
<h3 id="44-关键字参数"><a class="header" href="#44-关键字参数">4.4 关键字参数</a></h3>
<p>这里，我们对上面的C++代码做一点改造，就可以通知Python关于参数的名称（如本例中的“i”和“j”）。</p>
<pre><code class="language-c++">m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two numbers&quot;,
      py::arg(&quot;i&quot;), py::arg(&quot;j&quot;));
</code></pre>
<p>arg是可用于将元数据传递到module::def()的几个特殊标记类之一。使用上面修改后的代码，我们可以在调用函数时使用关键字参数，以增加代码可读性，特别是对那些带有多个参数的函数。</p>
<pre><code class="language-python">import example
example.add(i=1, j=2)  #3L
</code></pre>
<p>关键字名称也会在文档的函数签名中显示：</p>
<pre><code class="language-python">&gt;&gt;&gt; help(example)

....

FUNCTIONS
    add(...)
        Signature : (i: int, j: int) -&gt; int

        A function which adds two numbers
</code></pre>
<p>还可以使用更加简短的方式给参数命名：</p>
<pre><code class="language-c++">// regular notation
m.def(&quot;add1&quot;, &amp;add, py::arg(&quot;i&quot;), py::arg(&quot;j&quot;));
// shorthand
using namespace pybind11::literals;
m.def(&quot;add2&quot;, &amp;add, &quot;i&quot;_a, &quot;j&quot;_a);
</code></pre>
<p>后缀<code>_a</code>会生成一个等价于<code>arg</code>方法的字面量。使用这个后缀时，需要调用<code>using namespace pybind11::literals</code>来声明后缀所在的命名空间。这样除了<code>literals</code>外，不会从pybind11命名空间引入其他不必要的东西。</p>
<h3 id="45-默认参数"><a class="header" href="#45-默认参数">4.5 默认参数</a></h3>
<p>现在我们需要绑定一个带默认参数的函数：</p>
<pre><code class="language-c++">int add(int i = 1, int j = 2) {
    return i + j;
}
</code></pre>
<p>pybind11不能自动地提取默认参数，因为它不属于函数类型信息的一部分。我们需要借助<code>arg</code>来实现这一功能：</p>
<pre><code class="language-c++">m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two numbers&quot;,
      py::arg(&quot;i&quot;) = 1, py::arg(&quot;j&quot;) = 2);
</code></pre>
<p>默认值同样也会在文档中展示：</p>
<pre><code class="language-python">&gt;&gt;&gt; help(example)

....

FUNCTIONS
    add(...)
        Signature : (i: int = 1, j: int = 2) -&gt; int

        A function which adds two numbers
</code></pre>
<p>更简短的声明方式：</p>
<pre><code class="language-c++">// regular notation
m.def(&quot;add1&quot;, &amp;add, py::arg(&quot;i&quot;) = 1, py::arg(&quot;j&quot;) = 2);
// shorthand
m.def(&quot;add2&quot;, &amp;add, &quot;i&quot;_a=1, &quot;j&quot;_a=2);
</code></pre>
<h3 id="46-导出变量"><a class="header" href="#46-导出变量">4.6 导出变量</a></h3>
<p>我们可以使用<code>attr</code>函数来注册需要导出到Python模块中的C++变量。内建类型和常规对象（后面会细讲）会在指定attriutes时自动转换，也可以使用<code>py::cast</code>来显式转换。</p>
<pre><code class="language-c++">PYBIND11_MODULE(example, m) {
    m.attr(&quot;the_answer&quot;) = 42;
    py::object world = py::cast(&quot;World&quot;);
    m.attr(&quot;what&quot;) = world;
}
``

Python中使用如下：
​```pyhton
&gt;&gt;&gt; import example
&gt;&gt;&gt; example.the_answer
42
&gt;&gt;&gt; example.what
'World'
</code></pre>
<h3 id="47-支持的数据类型"><a class="header" href="#47-支持的数据类型">4.7 支持的数据类型</a></h3>
<p>原生支持大量数据类型，完美适用于函数参数，参数值通常直接返回或者经过py::cast处理再返回。有关完整概述，请参阅类型转换部分。(A large number of data types are supported out of the box and can be used seamlessly as functions arguments, return values or with py::cast in general. For a full overview, see the Type conversions section.)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="5-面对对象编程"><a class="header" href="#5-面对对象编程">5. 面对对象编程</a></h2>
<h3 id="51-创建一个自定义类的绑定"><a class="header" href="#51-创建一个自定义类的绑定">5.1 创建一个自定义类的绑定</a></h3>
<p>让我们来看一个更加复杂的例子：绑定一个C++自定义数据结构<code>Pet</code>。定义如下：</p>
<pre><code class="language-c++">struct Pet {
    Pet(const std::string &amp;name) : name(name) { }
    void setName(const std::string &amp;name_) { name = name_; }
    const std::string &amp;getName() const { return name; }

    std::string name;
};
</code></pre>
<p>绑定代码如下所示：</p>
<pre><code class="language-c++">#include &lt;pybind11/pybind11.h&gt;
namespace py = pybind11;

PYBIND11_MODULE(example, m) {
    py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
        .def(py::init&lt;const std::string &amp;&gt;())
        .def(&quot;setName&quot;, &amp;Pet::setName)
        .def(&quot;getName&quot;, &amp;Pet::getName);
}
</code></pre>
<p><code>class_</code>会创建C++ class或 struct的绑定。<code>init()</code>方法使用类构造函数的参数类型作为模板参数，并包装相应的构造函数（详见<a href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#custom-constructors">自定义构造函数</a>）。Python使用示例如下；</p>
<pre><code class="language-python">&gt;&gt;&gt; import example
&gt;&gt;&gt; p = example.Pet(&quot;Molly&quot;)
&gt;&gt;&gt; print(p)
&lt;example.Pet object at 0x10cd98060&gt;
&gt;&gt;&gt; p.getName()
u'Molly'
&gt;&gt;&gt; p.setName(&quot;Charly&quot;)
&gt;&gt;&gt; p.getName()
u'Charly'
</code></pre>
<blockquote>
<p><strong>See also</strong>：静态成员函数需要使用<code>class_::def_static</code>来绑定。</p>
</blockquote>
<h3 id="52-关键字参数和默认参数"><a class="header" href="#52-关键字参数和默认参数">5.2 关键字参数和默认参数</a></h3>
<p>可以使用第4章讨论的语法来指定关键字和默认参数，详见第4章相关章节。</p>
<h3 id="53-绑定匿名函数"><a class="header" href="#53-绑定匿名函数">5.3 绑定匿名函数</a></h3>
<p>使用<code>print(p)</code>打印对象信息时，上面的例子会得到一些基本无用的信息。</p>
<pre><code class="language-python">&gt;&gt;&gt; print(p)
&lt;example.Pet object at 0x10cd98060&gt;
</code></pre>
<p>我们可以绑定一个工具函数到<code>__repr__</code>方法，来返回可读性好的摘要信息。在不改变Pet类的基础上，使用一个匿名函数来完成这个功能是一个不错的选择。</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def(&quot;setName&quot;, &amp;Pet::setName)
    .def(&quot;getName&quot;, &amp;Pet::getName)
    .def(&quot;__repr__&quot;,
        [](const Pet &amp;a) {
            return &quot;&lt;example.Pet named '&quot; + a.name + &quot;'&gt;&quot;;
        });
</code></pre>
<p>通过上面的修改，Python中的输出如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; print(p)
&lt;example.Pet named 'Molly'&gt;
</code></pre>
<p>pybind11支持无状态和有状态的lambda闭包，即lambda表达式的<code>[]</code>是否带捕获参数。</p>
<h3 id="54-成员变量"><a class="header" href="#54-成员变量">5.4 成员变量</a></h3>
<p>使用<code>class_::def_readwrite</code>方法可以导出公有成员变量，使用<code>class_::def_readonly</code>方法则可以导出只读成员。</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def_readwrite(&quot;name&quot;, &amp;Pet::name)
    // ... remainder ...
</code></pre>
<p>Python中使用示例如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; p = example.Pet(&quot;Molly&quot;)
&gt;&gt;&gt; p.name
u'Molly'
&gt;&gt;&gt; p.name = &quot;Charly&quot;
&gt;&gt;&gt; p.name
u'Charly'
</code></pre>
<p>假设<code>Pet::name</code>是一个私有成员变量，向外提供setter和getters方法。</p>
<pre><code class="language-c++">class Pet {
public:
    Pet(const std::string &amp;name) : name(name) { }
    void setName(const std::string &amp;name_) { name = name_; }
    const std::string &amp;getName() const { return name; }
private:
    std::string name;
};
</code></pre>
<p>可以使用<code>class_::def_property()</code>(只读成员使用<code>class_::def_property_readonly()</code>)来定义并私有成员，并生成相应的setter和geter方法：</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def_property(&quot;name&quot;, &amp;Pet::getName, &amp;Pet::setName)
    // ... remainder ...
</code></pre>
<p>只写属性通过将read函数定义为nullptr来实现。</p>
<blockquote>
<p><strong>see also</strong>: 相似的方法<code>class_::def_readwrite_static()</code>, <code>class_::def_readonly_static()</code> <code>class_::def_property_static()</code>, <code>class_::def_property_readonly_static()</code>用于绑定静态变量和属性。</p>
</blockquote>
<h3 id="55-动态属性"><a class="header" href="#55-动态属性">5.5 动态属性</a></h3>
<p>原生的Pyhton类可以动态地获取新属性：</p>
<pre><code class="language-python">&gt;&gt;&gt; class Pet:
...    name = &quot;Molly&quot;
...
&gt;&gt;&gt; p = Pet()
&gt;&gt;&gt; p.name = &quot;Charly&quot;  # overwrite existing
&gt;&gt;&gt; p.age = 2  # dynamically add a new attribute
</code></pre>
<p>默认情况下，从C++导出的类不支持动态属性，其可写属性必须是通过<code>class_::def_readwrite</code>或<code>class_::def_property</code>定义的。试图设置其他属性将产生错误：</p>
<pre><code class="language-python">&gt;&gt;&gt; p = example.Pet()
&gt;&gt;&gt; p.name = &quot;Charly&quot;  # OK, attribute defined in C++
&gt;&gt;&gt; p.age = 2  # fail
AttributeError: 'Pet' object has no attribute 'age'
</code></pre>
<p>要让C++类也支持动态属性，我们需要在<code>py::class_</code>的构造函数添加<code>py::dynamic_attr</code>标识：</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;, py::dynamic_attr())
    .def(py::init&lt;&gt;())
    .def_readwrite(&quot;name&quot;, &amp;Pet::name);
</code></pre>
<p>这样，之前报错的代码就能够正常运行了。</p>
<pre><code class="language-python">&gt;&gt;&gt; p = example.Pet()
&gt;&gt;&gt; p.name = &quot;Charly&quot;  # OK, overwrite value in C++
&gt;&gt;&gt; p.age = 2  # OK, dynamically add a new attribute
&gt;&gt;&gt; p.__dict__  # just like a native Python class
{'age': 2}
</code></pre>
<p>需要提醒一下，支持动态属性会带来小小的运行时开销。不仅仅因为增加了额外的<code>__dict__</code>属性，还因为处理循环引用时需要花费更多的垃圾收集跟踪花销。但是不必担心这个问题，因为原生Python类也有同样的开销。默认情况下，pybind11导出的类比原生Python类效率更高，使能动态属性也只是让它们处于同等水平而已。</p>
<h3 id="56-继承与向下转型"><a class="header" href="#56-继承与向下转型">5.6 继承与向下转型</a></h3>
<p>现在有两个具有继承关系的类：</p>
<pre><code class="language-c++">struct Pet {
    Pet(const std::string &amp;name) : name(name) { }
    std::string name;
};

struct Dog : Pet {
    Dog(const std::string &amp;name) : Pet(name) { }
    std::string bark() const { return &quot;woof!&quot;; }
};
</code></pre>
<p>pybind11提供了两种方法来指明继承关系：1）将C++基类作为派生类<code>class_</code>的模板参数；2）将基类名作为<code>class_</code>的参数绑定到派生类。两种方法是等效的。</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
   .def(py::init&lt;const std::string &amp;&gt;())
   .def_readwrite(&quot;name&quot;, &amp;Pet::name);

// Method 1: template parameter:
py::class_&lt;Dog, Pet /* &lt;- specify C++ parent type */&gt;(m, &quot;Dog&quot;)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def(&quot;bark&quot;, &amp;Dog::bark);

// Method 2: pass parent class_ object:
py::class_&lt;Dog&gt;(m, &quot;Dog&quot;, pet /* &lt;- specify Python parent type */)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def(&quot;bark&quot;, &amp;Dog::bark);
</code></pre>
<p>指明继承关系后，派生类实例将获得两者的字段和方法：</p>
<pre><code class="language-python">&gt;&gt;&gt; p = example.Dog(&quot;Molly&quot;)
&gt;&gt;&gt; p.name
u'Molly'
&gt;&gt;&gt; p.bark()
u'woof!'
</code></pre>
<p>上面的例子是一个常规非多态的继承关系，表现在Python就是：</p>
<pre><code class="language-c++">// 返回一个指向派生类的基类指针
m.def(&quot;pet_store&quot;, []() { return std::unique_ptr&lt;Pet&gt;(new Dog(&quot;Molly&quot;)); });
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; p = example.pet_store()
&gt;&gt;&gt; type(p)  # `Dog` instance behind `Pet` pointer
Pet          # no pointer downcasting for regular non-polymorphic types
&gt;&gt;&gt; p.bark()
AttributeError: 'Pet' object has no attribute 'bark'
</code></pre>
<p><code>pet_store</code>函数返回了一个Dog实例，但由于基类并非多态类型，Python只识别到了Pet。在C++中，一个类至少有一个虚函数才会被视为多态类型。pybind11会自动识别这种多态机制。</p>
<pre><code class="language-c++">struct PolymorphicPet {
    virtual ~PolymorphicPet() = default;
};

struct PolymorphicDog : PolymorphicPet {
    std::string bark() const { return &quot;woof!&quot;; }
};

// Same binding code
py::class_&lt;PolymorphicPet&gt;(m, &quot;PolymorphicPet&quot;);
py::class_&lt;PolymorphicDog, PolymorphicPet&gt;(m, &quot;PolymorphicDog&quot;)
    .def(py::init&lt;&gt;())
    .def(&quot;bark&quot;, &amp;PolymorphicDog::bark);

// Again, return a base pointer to a derived instance
m.def(&quot;pet_store2&quot;, []() { return std::unique_ptr&lt;PolymorphicPet&gt;(new PolymorphicDog); });
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; p = example.pet_store2()
&gt;&gt;&gt; type(p)
PolymorphicDog  # automatically downcast
&gt;&gt;&gt; p.bark()
u'woof!'
</code></pre>
<p>pybind11会自动地将一个指向多态基类的指针，向下转型为实际的派生类类型。这和C++常见的情况不同，我们不仅可以访问基类的虚函数，还能获取到通过基类看不到的，具体的派生类的方法和属性。</p>
<h3 id="57-重载方法"><a class="header" href="#57-重载方法">5.7 重载方法</a></h3>
<p>重载方法即拥有相同的函数名，但入参不一样的函数：</p>
<pre><code class="language-c++">struct Pet {
    Pet(const std::string &amp;name, int age) : name(name), age(age) { }

    void set(int age_) { age = age_; }
    void set(const std::string &amp;name_) { name = name_; }

    std::string name;
    int age;
};
</code></pre>
<p>我们在绑定<code>Pet::set</code>时会报错，因为编译器并不知道用户想选择哪个重载方法。我们需要添加具体的函数指针来消除歧义。绑定多个函数到同一个Python名称，将会自动创建函数重载链。Python将会依次匹配，找到最合适的重载函数。</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
   .def(py::init&lt;const std::string &amp;, int&gt;())
   .def(&quot;set&quot;, static_cast&lt;void (Pet::*)(int)&gt;(&amp;Pet::set), &quot;Set the pet's age&quot;)
   .def(&quot;set&quot;, static_cast&lt;void (Pet::*)(const std::string &amp;)&gt;(&amp;Pet::set), &quot;Set the pet's name&quot;);
</code></pre>
<p>在函数的文档描述中，我们可以看见重载的函数签名：</p>
<pre><code class="language-python">&gt;&gt;&gt; help(example.Pet)

class Pet(__builtin__.object)
 |  Methods defined here:
 |
 |  __init__(...)
 |      Signature : (Pet, str, int) -&gt; NoneType
 |
 |  set(...)
 |      1. Signature : (Pet, int) -&gt; NoneType
 |
 |      Set the pet's age
 |
 |      2. Signature : (Pet, str) -&gt; NoneType
 |
 |      Set the pet's name
</code></pre>
<p>如果你的编译器支持C++14，也可以使用下面的语法来转换重载函数：</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
    .def(&quot;set&quot;, py::overload_cast&lt;int&gt;(&amp;Pet::set), &quot;Set the pet's age&quot;)
    .def(&quot;set&quot;, py::overload_cast&lt;const std::string &amp;&gt;(&amp;Pet::set), &quot;Set the pet's name&quot;);
</code></pre>
<p>这里，<code>py::overload_cast</code>仅需指定函数类型，不用给出返回值类型，以避免原语法带来的不必要的干扰(<code>void (Pet::*)</code>)。如果是基于const的重载，需要使用<code>py::const</code>标识。</p>
<pre><code class="language-c++">struct Widget {
    int foo(int x, float y);
    int foo(int x, float y) const;
};

py::class_&lt;Widget&gt;(m, &quot;Widget&quot;)
   .def(&quot;foo_mutable&quot;, py::overload_cast&lt;int, float&gt;(&amp;Widget::foo))
   .def(&quot;foo_const&quot;,   py::overload_cast&lt;int, float&gt;(&amp;Widget::foo, py::const_));
</code></pre>
<p>如果你想在仅支持c++11的编译器上使用<code>py::overload_cast</code>语法，可以使用<code>py::detail::overload_cast_impl</code>来代替：</p>
<pre><code class="language-c++">template &lt;typename... Args&gt;
using overload_cast_ = pybind11::detail::overload_cast_impl&lt;Args...&gt;;

py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
    .def(&quot;set&quot;, overload_cast_&lt;int&gt;()(&amp;Pet::set), &quot;Set the pet's age&quot;)
    .def(&quot;set&quot;, overload_cast_&lt;const std::string &amp;&gt;()(&amp;Pet::set), &quot;Set the pet's name&quot;);
</code></pre>
<blockquote>
<p>Note: 如果想定义多个重载的构造函数，使用<code>.def(py::init&lt;...&gt;())</code>语法依次定义就好，指定关键字和默认参数的机制也还是生效的。</p>
</blockquote>
<h3 id="58-枚举和内部类型"><a class="header" href="#58-枚举和内部类型">5.8 枚举和内部类型</a></h3>
<p>现在有一个含有枚举和内部类型的类：</p>
<pre><code class="language-c++">struct Pet {
    enum Kind {
        Dog = 0,
        Cat
    };

    struct Attributes {
        float age = 0;
    };

    Pet(const std::string &amp;name, Kind type) : name(name), type(type) { }

    std::string name;
    Kind type;
    Attributes attr;
};
</code></pre>
<p>绑定代码如下所示：</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt; pet(m, &quot;Pet&quot;);

pet.def(py::init&lt;const std::string &amp;, Pet::Kind&gt;())
    .def_readwrite(&quot;name&quot;, &amp;Pet::name)
    .def_readwrite(&quot;type&quot;, &amp;Pet::type)
    .def_readwrite(&quot;attr&quot;, &amp;Pet::attr);

py::enum_&lt;Pet::Kind&gt;(pet, &quot;Kind&quot;)
    .value(&quot;Dog&quot;, Pet::Kind::Dog)
    .value(&quot;Cat&quot;, Pet::Kind::Cat)
    .export_values();

py::class_&lt;Pet::Attributes&gt; attributes(pet, &quot;Attributes&quot;)
    .def(py::init&lt;&gt;())
    .def_readwrite(&quot;age&quot;, &amp;Pet::Attributes::age);
</code></pre>
<p>为确保嵌套类型<code>Kind</code>和<code>Attributes</code>在<code>Pet</code>的作用域中创建，我们必须向<code>enum_</code>和<code>class_</code>的构造函数提供<code>Pet</code> <code>class_</code>实例。<code>enum_::export_values()</code>用来导出枚举项到父作用域，C++11的强枚举类型需要跳过这点。</p>
<pre><code class="language-python">&gt;&gt;&gt; p = Pet(&quot;Lucy&quot;, Pet.Cat)
&gt;&gt;&gt; p.type
Kind.Cat
&gt;&gt;&gt; int(p.type)
1L
</code></pre>
<p>枚举类型的枚举项会被导出到类<code>__members__</code>属性中：</p>
<pre><code class="language-python">&gt;&gt;&gt; Pet.Kind.__members__
{'Dog': Kind.Dog, 'Cat': Kind.Cat}
</code></pre>
<p><code>name</code>属性可以返回枚举值的名称的unicode字符串，<code>str(enum)</code>也可以做到，但两者的实现目标不同。下面的例子展示了两者的差异：</p>
<pre><code class="language-python">&gt;&gt;&gt; p = Pet(&quot;Lucy&quot;, Pet.Cat)
&gt;&gt;&gt; pet_type = p.type
&gt;&gt;&gt; pet_type
Pet.Cat
&gt;&gt;&gt; str(pet_type)
'Pet.Cat'
&gt;&gt;&gt; pet_type.name
'Cat'
</code></pre>
<blockquote>
<p>Note: 当我们给<code>enum_</code>的构造函数增加<code>py::arithmetic()</code>标识时，pybind11将创建一个支持基本算术运算和位运算（如比较、或、异或、取反等）的枚举类型。</p>
<pre><code class="language-c++">py::enum_&lt;Pet::Kind&gt;(pet, &quot;Kind&quot;, py::arithmetic())
   ...
</code></pre>
<p>默认情况下，省略这些可以节省内存空间。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="6-构建系统"><a class="header" href="#6-构建系统">6. 构建系统</a></h2>
<p>后续再翻译。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="7-函数"><a class="header" href="#7-函数">7. 函数</a></h2>
<p>在开始本节前，请确保你已经熟悉了第4章和第5章讲述的函数和类绑定的基本方法。下面我们将继续讲述普通函数、成员函数、以及Python方法的知识点。</p>
<h3 id="71-返回值策略"><a class="header" href="#71-返回值策略">7.1 返回值策略</a></h3>
<p>Python和C++在管理内存和对象生命周期管理上存在本质的区别。这导致我们在创建返回no-trivial类型的函数绑定时会出问题。仅通过类型信息，我们无法明确是Python侧需要接管返回值并负责释放资源，还是应该由C++侧来处理。因此，pybind11提供了一些返回值策略来确定由哪方管理资源。这些策略通过<code>model::def()</code>和<code>class_def()</code>来指定，默认策略为<code>return_value_policy::automatic</code>。</p>
<p>返回值策略难以捉摸，正确地选择它们则显得尤为重要。下面我们通过一个简单的例子来阐释选择错误的情形：</p>
<pre><code class="language-c++">/* Function declaration */
Data *get_data() { return _data; /* (pointer to a static data structure) */ }
...

/* Binding code */
m.def(&quot;get_data&quot;, &amp;get_data); // &lt;-- KABOOM, will cause crash when called from Python
</code></pre>
<p>当Python侧调用<code>get_data()</code>方法时，返回值（原生C++类型）必须被转换为合适的Python类型。在这个例子中，默认的返回值策略（<code>return_value_policy::automatic</code>）使得pybind11获取到了静态变量<code>_data</code>的所有权。</p>
<p>当Python垃圾收集器最终删除<code>_data</code>的Python封装时，pybind11将尝试删除C++实例（通过operator delete()）。这时，这个程序将以某种隐蔽的错误并涉及静默数据破坏的方式崩溃。</p>
<p>对于上面的例子，我们应该指定返回值策略为<code>return_value_policy::reference</code>，这样全局变量的实例仅仅被引用，而不涉及到所有权的转移：</p>
<pre><code class="language-c++">m.def(&quot;get_data&quot;, &amp;get_data, py::return_value_policy::reference);
</code></pre>
<p>另一方面，引用策略在多数其他场合并不是正确的策略，忽略所有权的归属可能导致资源泄漏。作为一个使用pybind11的开发者，熟悉不同的返回值策略及其适用场合尤为重要。下面的表格将提供所有策略的概览：</p>
<div class="table-wrapper"><table><thead><tr><th>返回值策略</th><th>描述</th></tr></thead><tbody>
<tr><td><code>return_value_policy::take_ownership</code></td><td>引用现有对象（不创建一个新对象），并获取所有权。在引用计数为0时，Pyhton将调用析构函数和delete操作销毁对象。</td></tr>
<tr><td><code>return_value_policy::copy</code></td><td>拷贝返回值，这样Python将拥有拷贝的对象。该策略相对来说比较安全，因为两个实例的生命周期是分离的。</td></tr>
<tr><td><code>return_value_policy::move</code></td><td>使用<code>std::move</code>来移动返回值的内容到新实例，新实例的所有权在Python。该策略相对来说比较安全，因为两个实例的生命周期是分离的。</td></tr>
<tr><td><code>return_value_policy::reference</code></td><td>引用现有对象，但不拥有所有权。C++侧负责该对象的生命周期管理，并在对象不再被使用时负责析构它。注意：当Python侧还在使用引用的对象时，C++侧删除对象将导致未定义行为。</td></tr>
<tr><td><code>return_value_policy::reference_internal</code></td><td>返回值的生命周期与父对象的生命周期相绑定，即被调用函数或属性的<code>this</code>或<code>self</code>对象。这种策略与reference策略类似，但附加了<code>keep_alive&lt;0, 1&gt;</code>调用策略保证返回值还被Python引用时，其父对象就不会被垃圾回收掉。这是由<code>def_property</code>、<code>def_readwrite</code>创建的属性getter方法的默认返回值策略。</td></tr>
<tr><td><code>return_value_policy::automatic</code></td><td>当返回值是指针时，该策略使用<code>return_value_policy::take_ownership</code>。反之对左值和右值引用使用<code>return_value_policy::copy</code>。请参阅上面的描述，了解所有这些不同的策略的作用。这是<code>py::class_</code>封装类型的默认策略。</td></tr>
<tr><td><code>return_value_policy::automatic_reference</code></td><td>和上面一样，但是当返回值是指针时，使用<code>return_value_policy::reference</code>策略。这是在C++代码手动调用Python函数和使用<code>pybind11/stl.h</code>中的casters时的默认转换策略。你可能不需要显式地使用该策略。</td></tr>
</tbody></table>
</div>
<p>返回值策略也可以应用于属性：</p>
<pre><code class="language-c++">class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)
    .def_property(&quot;data&quot;, &amp;MyClass::getData, &amp;MyClass::setData,
                  py::return_value_policy::copy);
</code></pre>
<p>在技术层面，上述代码会将策略同时应用于getter和setter函数，但是setter函数并不关心返回值策略，这样做仅仅出于语法简洁的考虑。或者，你可以通过<code>cpp_function</code>构造函数来传递目标参数：</p>
<pre><code class="language-c++">class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)
    .def_property(&quot;data&quot;
        py::cpp_function(&amp;MyClass::getData, py::return_value_policy::copy),
        py::cpp_function(&amp;MyClass::setData)
    );
</code></pre>
<p><strong>注意</strong>：代码使用无效的返回值策略将导致未初始化内存或多次free数据结构，这将导致难以调试的、不确定的问题和段错误。因此，花点时间来理解上面表格的各个选项是值得的。</p>
<p><strong>提示</strong>：</p>
<ol>
<li>上述策略的另一个重点是，他们仅可以应用于pybind11还不知晓的实例，这时策略将澄清返回值的生命周期和所有权问题。当pybind11已经知晓参数（通过其在内存中的类型和地址来识别），它将返回已存在的Python对象封装，而不是创建一份拷贝。</li>
<li>下一节将讨论上面表格之外的调用策略，他涉及到返回值和函数参数的引用关系。</li>
<li>可以考虑使用智能指针来代替复杂的调用策略和生命周期管理逻辑。智能指针会告诉你一个对象是否仍被C++或Python引用，这样就可以消除各种可能引发crash或未定义行为的矛盾。对于返回智能指针的函数，没必要指定返回值策略。</li>
</ol>
<h3 id="72-附加的调用策略"><a class="header" href="#72-附加的调用策略">7.2 附加的调用策略</a></h3>
<p>除了以上的返回值策略外，进一步指定调用策略可以表明参数间的依赖关系，确保函数调用的稳定性。</p>
<h4 id="保活keep-alive"><a class="header" href="#保活keep-alive">保活（keep alive）</a></h4>
<p>当一个C++容器对象包含另一个C++对象时，我们需要使用该策略。<code>keep_alive&lt;Nurse, Patient&gt;</code>表明至少在索引Nurse被回收前，索引Patient应该被保活。0表示返回值，1及以上表示参数索引。1表示隐含的参数this指针，而常规参数索引从2开始。当Nurse的值在运行前被检测到为None时，调用策略将什么都不做。</p>
<p>当nurse不是一个pybind11注册类型时，实现依赖于创建对nurse对象弱引用的能力。如果nurse对象不是pybind11注册类型，也不支持弱引用，程序将会抛出异常。</p>
<p>如果你使用一个错误的参数索引，程序将会抛出&quot;Could not cativate keep_alive!&quot;警告的运行时异常。这时，你应该review你代码中使用的索引。</p>
<p>参见下面的例子：一个list append操作，将新添加元素的生命周期绑定到添加的容器对象上：</p>
<pre><code class="language-c++">py::class_&lt;List&gt;(m, &quot;List&quot;).def(&quot;append&quot;, &amp;List::append, py::keep_alive&lt;1, 2&gt;());
</code></pre>
<p>为了一致性，构造函数的实参索引也是相同的。索引1仍表示this指针，索引0表示返回值（构造函数的返回值被认为是void）。下面的示例将构造函数入参的生命周期绑定到被构造对象上。</p>
<pre><code class="language-c++">py::class_&lt;Nurse&gt;(m, &quot;Nurse&quot;).def(py::init&lt;Patient &amp;&gt;(), py::keep_alive&lt;1, 2&gt;());
</code></pre>
<blockquote>
<p>Note: <code>keep_alive</code>与Boost.Python中的<code>with_custodian_and_ward</code>和<code>with_custodian_and_ward_postcall</code>相似。</p>
</blockquote>
<h4 id="call-guard"><a class="header" href="#call-guard">Call guard</a></h4>
<p><code>call_guard&lt;T&gt;</code>策略允许任意T类型的scope guard应用于整个函数调用。示例如下：</p>
<pre><code class="language-c++">m.def(&quot;foo&quot;, foo, py::call_guard&lt;T&gt;());
</code></pre>
<p>上面的代码等价于：</p>
<pre><code class="language-c++">m.def(&quot;foo&quot;, [](args...) {
    T scope_guard;
    return foo(args...); // forwarded arguments
});
</code></pre>
<p>仅要求模板参数T是可构造的，如<code>gil_scoped_release</code>就是一个非常有用的类型。</p>
<p><code>call_guard</code>支持同时制定多个模板参数，<code>call_guard&lt;T1, T2, T3 ...&gt;</code>。构造顺序是从左至右，析构顺序则相反。</p>
<blockquote>
<p>See also: <code>test/test_call_policies.cpp</code>含有更丰富的示例来展示<code>keep_alive</code>和<code>call_guard</code>的用法。</p>
</blockquote>
<h3 id="73-以python对象作为参数"><a class="header" href="#73-以python对象作为参数">7.3 以Python对象作为参数</a></h3>
<p>pybind11通过简单的C++封装类，公开了绝大多数Python类型。这些封装类也可以在绑定代码宏作为函数参数使用，这样我们就可以在C++侧使用原生的python类型。举个遍历Python dict的例子：</p>
<pre><code class="language-c++">void print_dict(const py::dict&amp; dict) {
    /* Easily interact with Python types */
    for (auto item : dict)
        std::cout &lt;&lt; &quot;key=&quot; &lt;&lt; std::string(py::str(item.first)) &lt;&lt; &quot;, &quot;
                  &lt;&lt; &quot;value=&quot; &lt;&lt; std::string(py::str(item.second)) &lt;&lt; std::endl;
}

// it can be exported as follow:
m.def(&quot;print_dict&quot;, &amp;print_dict);
</code></pre>
<p>在Python中使用如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; print_dict({&quot;foo&quot;: 123, &quot;bar&quot;: &quot;hello&quot;})
key=foo, value=123
key=bar, value=hello
</code></pre>
<h3 id="74-接收args和kwatgs参数"><a class="header" href="#74-接收args和kwatgs参数">7.4 接收<code>*args</code>和<code>**kwatgs</code>参数</a></h3>
<p>Python的函数可以接收任意数量的参数和关键字参数：</p>
<pre><code class="language-python">def generic(*args, **kwargs):
    ...  # do something with args and kwargs
</code></pre>
<p>我们也可以通过pybind11来创建这样的函数：</p>
<pre><code class="language-c++">void generic(py::args args, const py::kwargs&amp; kwargs) {
    /// .. do something with args
    if (kwargs)
        /// .. do something with kwargs
}

/// Binding code
m.def(&quot;generic&quot;, &amp;generic);
</code></pre>
<p><code>py::args</code>继承自<code>py::tuple</code>，<code>py::kwargs</code>继承自<code>py::dict</code>。</p>
<p>更多示例参考<code>test/test_kwargs_and_defualts.cpp</code>。</p>
<h3 id="75-再探默认参数"><a class="header" href="#75-再探默认参数">7.5 再探默认参数</a></h3>
<p>前面的章节已经讨论了默认参数的基本用法。关于实现有一个值得关注的点，就是默认参数在声明时就被转换为Python对象了。看看下面的例子：</p>
<pre><code class="language-c++">py::class_&lt;MyClass&gt;(&quot;MyClass&quot;).def(&quot;myFunction&quot;, py::arg(&quot;arg&quot;) = SomeType(123));
</code></pre>
<p>这个例子里，必须保证SomeType类型已经被binding了（通过py::class_<SomeType>），不然就会抛出异常。</p>
<p>另一个值得注意的事情就是，生成的函数签名将使用对象的<code>__repr__</code>方法来处理默认参数值。如果对象没有提供该方法，那么函数签名将不能直观的看出默认参数值。</p>
<pre><code>FUNCTIONS

|  myFunction(...)
|      Signature : (MyClass, arg : SomeType = &lt;SomeType object at 0x101b7b080&gt;) -&gt; NoneType

</code></pre>
<p>要处理这个问题，我们需要定义<code>SomeType.__repr__</code>方法，或者使用<code>arg_v</code>给默认参数手动添加方便阅读的注释。</p>
<pre><code class="language-c++">py::class_&lt;MyClass&gt;(&quot;MyClass&quot;)
    .def(&quot;myFunction&quot;, py::arg_v(&quot;arg&quot;, SomeType(123), &quot;SomeType(123)&quot;));
``

有时，可能需要使用空指针作为默认参数：
​```c++
py::class_&lt;MyClass&gt;(&quot;MyClass&quot;)
    .def(&quot;myFunction&quot;, py::arg(&quot;arg&quot;) = static_cast&lt;SomeType *&gt;(nullptr));
</code></pre>
<h3 id="76-keyword-only参数"><a class="header" href="#76-keyword-only参数">7.6 Keyword-only参数</a></h3>
<p>Python3提供了keyword-only参数（在函数定义中使用<code>*</code>作为匿名参数）：</p>
<pre><code class="language-python">def f(a, *, b):  # a can be positional or via keyword; b must be via keyword
    pass

f(a=1, b=2)  # good
f(b=2, a=1)  # good
f(1, b=2)  # good
f(1, 2)  # TypeError: f() takes 1 positional argument but 2 were given
</code></pre>
<p>pybind11提供了<code>py::kw_only</code>对象来实现相同的功能：</p>
<pre><code class="language-c++">m.def(&quot;f&quot;, [](int a, int b) { /* ... */ },
      py::arg(&quot;a&quot;), py::kw_only(), py::arg(&quot;b&quot;));
</code></pre>
<p>注意，该特性不能与<code>py::args</code>一起使用。</p>
<h3 id="77-positional-only参数"><a class="header" href="#77-positional-only参数">7.7 Positional-only参数</a></h3>
<p>python3.8引入了Positional-only参数语法，pybind11通过<code>py::pos_only()</code>来提供相同的功能：</p>
<pre><code class="language-c++">m.def(&quot;f&quot;, [](int a, int b) { /* ... */ },
       py::arg(&quot;a&quot;), py::pos_only(), py::arg(&quot;b&quot;));
</code></pre>
<p>现在，你不能通过关键字来给定<code>a</code>参数。该特性可以和keyword-only参数一起使用。</p>
<h3 id="78-non-converting参数"><a class="header" href="#78-non-converting参数">7.8 Non-converting参数</a></h3>
<p>有些参数可能支持类型转换，如：</p>
<ul>
<li>通过<code>py::implicitly_convertible&lt;A,B&gt;()</code>进行隐式转换</li>
<li>将整形变量传给入参为浮点类型的函数</li>
<li>将非复数类型（如float）传给入参为<code>std::complex&lt;float&gt;</code>类型的函数</li>
<li>Calling a function taking an Eigen matrix reference with a numpy array of the wrong type or of an incompatible data layout.</li>
</ul>
<p>有时这种转换并不是我们期望的，我们可能更希望绑定代码抛出错误，而不是转换参数。通过<code>py::arg</code>来调用<code>.noconvert()</code>方法可以实现这个事情。</p>
<pre><code class="language-c++">m.def(&quot;floats_only&quot;, [](double f) { return 0.5 * f; }, py::arg(&quot;f&quot;).noconvert());
m.def(&quot;floats_preferred&quot;, [](double f) { return 0.5 * f; }, py::arg(&quot;f&quot;));
</code></pre>
<p>尝试进行转换时，将抛出<code>TypeError</code>异常：</p>
<pre><code class="language-python">&gt;&gt;&gt; floats_preferred(4)
2.0
&gt;&gt;&gt; floats_only(4)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: floats_only(): incompatible function arguments. The following argument types are supported:
    1. (f: float) -&gt; float

Invoked with: 4
</code></pre>
<p>该方法可以与缩写符号<code>_a</code>和默认参数配合使用，像这样<code>py::arg().noconvert()</code>。</p>
<h3 id="79-允许禁止空参数"><a class="header" href="#79-允许禁止空参数">7.9 允许/禁止空参数</a></h3>
<p>当函数接受由<code>py::class_</code>注册的C++类型的指针或shared holder(如指针指针等)，pybind11允许将Python的None传递给函数，等同于C++中传递nullptr给函数。</p>
<p>我们可以使用<code>py::arg</code>对象的<code>.none</code>方法来显式地使能或禁止该行为。</p>
<pre><code class="language-c++">py::class_&lt;Dog&gt;(m, &quot;Dog&quot;).def(py::init&lt;&gt;());
py::class_&lt;Cat&gt;(m, &quot;Cat&quot;).def(py::init&lt;&gt;());
m.def(&quot;bark&quot;, [](Dog *dog) -&gt; std::string {
    if (dog) return &quot;woof!&quot;; /* Called with a Dog instance */
    else return &quot;(no dog)&quot;; /* Called with None, dog == nullptr */
}, py::arg(&quot;dog&quot;).none(true));
m.def(&quot;meow&quot;, [](Cat *cat) -&gt; std::string {
    // Can't be called with None argument
    return &quot;meow&quot;;
}, py::arg(&quot;cat&quot;).none(false));
</code></pre>
<p>这样，Python调用<code>bark(None)</code>将返回<code>&quot;(no dog)&quot;</code>，调用<code>meow(None)</code>将抛出异常<code>TypeError</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; from animals import Dog, Cat, bark, meow
&gt;&gt;&gt; bark(Dog())
'woof!'
&gt;&gt;&gt; meow(Cat())
'meow'
&gt;&gt;&gt; bark(None)
'(no dog)'
&gt;&gt;&gt; meow(None)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: meow(): incompatible function arguments. The following argument types are supported:
    1. (cat: animals.Cat) -&gt; str

Invoked with: None
</code></pre>
<p>在不显式指定的情况下，默认支持传递<code>None</code>。</p>
<blockquote>
<p>Note: Even when <code>.none(true)</code> is specified for an argument, <code>None</code> will be converted to a <code>nullptr</code> <em>only</em> for custom and <a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque">opaque</a> types. Pointers to built-in types (<code>double *</code>, <code>int *</code>, …) and STL types (<code>std::vector&lt;T&gt; *</code>, …; if <code>pybind11/stl.h</code> is included) are copied when converted to C++ (see <a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html">Overview</a>) and will not allow <code>None</code> as argument. To pass optional argument of these copied types consider using <code>std::optional&lt;T&gt;</code></p>
</blockquote>
<h3 id="710-重载解析顺序"><a class="header" href="#710-重载解析顺序">7.10 重载解析顺序</a></h3>
<p>当一个函数或者方法拥有多个重载时，pybind11通过两个步骤来决定重载调用的次序。第一步尝试不做类型匹配各个重载函数。如果没有匹配到，第二步将允许类型转换再匹配一次（显示调用<code>py::arg().noconvert()</code>禁用类型转换的函数除外）。</p>
<p>如果两步都失败了，将抛出异常<code>TypeError</code>。</p>
<p>在上述两步中，重载函数将以pybind11中注册的顺序依次遍历。如果函数定义中增加了<code>py::prepend()</code>的标识，该重载函数将最先被遍历。</p>
<blockquote>
<p>Note: pybind11不会根据重载参数的数量或类型来排优先级。换言之，pybind11不会将仅需一次类型转换的函数排在需要三次转换的函数前面，仅仅会将不需要类型转换的重载函数排在至少需要一次类型转换的函数前面。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="8-类"><a class="header" href="#8-类">8. 类</a></h2>
<p>本章将在第五章的基础上，进一步讲解类的绑定方法。</p>
<h3 id="81-在python中重载虚函数"><a class="header" href="#81-在python中重载虚函数">8.1 在Python中重载虚函数</a></h3>
<p>假设有一个含有虚函数的C++类或接口，我们想在Python中重载虚函数。</p>
<pre><code class="language-c++">class Animal {
public:
    virtual ~Animal() { }
    virtual std::string go(int n_times) = 0;
};

class Dog : public Animal {
public:
    std::string go(int n_times) override {
        std::string result;
        for (int i=0; i&lt;n_times; ++i)
            result += &quot;woof! &quot;;
        return result;
    }
};
</code></pre>
<p>现在有一个普通函数，它调用任意Animal实例的<code>go()</code>函数。</p>
<pre><code class="language-c++">std::string call_go(Animal *animal) {
    return animal-&gt;go(3);
}
</code></pre>
<p>pybind11绑定代码如下：</p>
<pre><code class="language-c++">PYBIND11_MODULE(example, m) {
    py::class_&lt;Animal&gt;(m, &quot;Animal&quot;)
        .def(&quot;go&quot;, &amp;Animal::go);

    py::class_&lt;Dog, Animal&gt;(m, &quot;Dog&quot;)
        .def(py::init&lt;&gt;());

    m.def(&quot;call_go&quot;, &amp;call_go);
}
</code></pre>
<p>但是，这样绑定不可扩展，当我们尝试继承Animal类时会提示&quot;No constructor defined!&quot;，因为Animal无法构造。这时，我们需要类似于&quot;跳板(trampoline)&quot;的工具来重定向虚函数调用到Python中。</p>
<p>我们可以在Python中定义一个新的Animal类作为辅助跳板：</p>
<pre><code class="language-c++">class PyAnimal : public Animal {
public:
    /* Inherit the constructors */
    using Animal::Animal;

    /* Trampoline (need one for each virtual function) */
    std::string go(int n_times) override {
        PYBIND11_OVERRIDE_PURE(
            std::string, /* Return type */
            Animal,      /* Parent class */
            go,          /* Name of function in C++ (must match Python name) */
            n_times      /* Argument(s) */
        );
    }
};
</code></pre>
<p>定义纯虚函数时需要使用<code>PYBIND11_OVERRIDE_PURE</code>宏，而有默认实现的虚函数则使用<code>PYBIND11_OVERRIDE</code>。<code>PYBIND11_OVERRIDE_PURE_NAME</code> 和<code>PYBIND11_OVERRIDE_NAME</code> 宏的功能类似，主要用于C函数名和Python函数名不一致的时候。以<code>__str__</code>为例：</p>
<pre><code class="language-c++">std::string toString() override {
  PYBIND11_OVERRIDE_NAME(
      std::string, // Return type (ret_type)
      Animal,      // Parent class (cname)
      &quot;__str__&quot;,   // Name of method in Python (name)
      toString,    // Name of function in C++ (fn)
  );
}
</code></pre>
<p>Animal类的绑定代码也需要一些微调：</p>
<pre><code class="language-c++">PYBIND11_MODULE(example, m) {
    py::class_&lt;Animal, PyAnimal /* &lt;--- trampoline*/&gt;(m, &quot;Animal&quot;)
        .def(py::init&lt;&gt;())
        .def(&quot;go&quot;, &amp;Animal::go);

    py::class_&lt;Dog, Animal&gt;(m, &quot;Dog&quot;)
        .def(py::init&lt;&gt;());

    m.def(&quot;call_go&quot;, &amp;call_go);
}
</code></pre>
<p>pybind11通过向<code>class_</code>指定额外的模板参数PyAnimal，让我们可以在Python中继承Animal类。</p>
<p>接下来，我们可以像往常一样定义构造函数。绑定时我们需要使用真实类，而不是辅助类。</p>
<pre><code class="language-c++">py::class_&lt;Animal, PyAnimal /* &lt;--- trampoline*/&gt;(m, &quot;Animal&quot;);
    .def(py::init&lt;&gt;())
    .def(&quot;go&quot;, &amp;PyAnimal::go); /* &lt;--- THIS IS WRONG, use &amp;Animal::go */
</code></pre>
<p>但是，上面的改动可以让我们在Python中继承Animal类，而不能继承Dog类。后续章节将会在此基础上进一步改进。</p>
<p>下面的Python代码展示了我们继承并重载了<code>Animal::go</code>方法，并通过虚函数来调用它：</p>
<pre><code class="language-python">from example import *
d = Dog()
call_go(d)     # u'woof! woof! woof! '
class Cat(Animal):
    def go(self, n_times):
        return &quot;meow! &quot; * n_times

c = Cat()
call_go(c)   # u'meow! meow! meow! '
</code></pre>
<p>如果你在派生的Python类中自定义了一个构造函数，你必须保证显示调用C++构造函数(通过<code>__init__</code>)，不管它是否为默认构造函数。否则，实例属于C++那部分的内存就未初始化，可能导致未定义行为。在pybind11 2.6版本中，这种错误将会抛出<code>TypeError</code>异常。</p>
<pre><code class="language-python">class Dachshund(Dog):
    def __init__(self, name):
        Dog.__init__(self)  # Without this, a TypeError is raised.
        self.name = name

    def bark(self):
        return &quot;yap!&quot;
</code></pre>
<p>注意必须显式地调用<code>__init__</code>，而不应该使用<code>supper()</code>。在一些简单的线性继承中，<code>supper()</code>或许可以正常工作；一旦你混合Python和C++类使用多重继承，由于Python MRO和C++的机制，一切都将崩溃。</p>
<blockquote>
<p>Note：</p>
<p>当重载函数返回一个pybind11从Python中转换过来的类型的引用或指针时，有些限制条件需要注意下：</p>
<ul>
<li>because in these cases there is no C++ variable to reference (the value is stored in the referenced Python variable), pybind11 provides one in the PYBIND11_OVERRIDE macros (when needed) with static storage duration. Note that this means that invoking the overridden method on <em>any</em> instance will change the referenced value stored in <em>all</em> instances of that type.</li>
<li>Attempts to modify a non-const reference will not have the desired effect: it will change only the static cache variable, but this change will not propagate to underlying Python instance, and the change will be replaced the next time the override is invoked.</li>
</ul>
</blockquote>
<h3 id="82-虚函数与继承"><a class="header" href="#82-虚函数与继承">8.2 虚函数与继承</a></h3>
<p>综合考虑虚函数与继承时，你需要为每个你允许在Python派生类中重载的方法提供重载方式。下面我们扩展Animal和Dog来举例：</p>
<pre><code class="language-c++">class Animal {
public:
    virtual std::string go(int n_times) = 0;
    virtual std::string name() { return &quot;unknown&quot;; }
};
class Dog : public Animal {
public:
    std::string go(int n_times) override {
        std::string result;
        for (int i=0; i&lt;n_times; ++i)
            result += bark() + &quot; &quot;;
        return result;
    }
    virtual std::string bark() { return &quot;woof!&quot;; }
};
</code></pre>
<p>上节涉及到的Animal辅助类仍是必须的，为了让Python代码能够继承<code>Dog</code>类，我们也需要为<code>Dog</code>类增加一个跳板类，来实现<code>bark()</code>和继承自Animal的<code>go()</code>、<code>name()</code>等重载方法（即便Dog类并不直接重载name方法）。</p>
<pre><code class="language-c++">class PyAnimal : public Animal {
public:
    using Animal::Animal; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, Animal, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, Animal, name, ); }
};
class PyDog : public Dog {
public:
    using Dog::Dog; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE(std::string, Dog, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, Dog, name, ); }
    std::string bark() override { PYBIND11_OVERRIDE(std::string, Dog, bark, ); }
};
</code></pre>
<blockquote>
<p>注意到<code>name()</code>和<code>bark()</code>尾部的逗号，这用来说明辅助类的函数不带任何参数。当函数至少有一个参数时，应该省略尾部的逗号。</p>
</blockquote>
<p>注册一个继承已经在pybind11中注册的带虚函数的类，同样需要为其添加辅助类，即便它没有定义或重载任何虚函数：</p>
<pre><code class="language-c++">class Husky : public Dog {};
class PyHusky : public Husky {
public:
    using Husky::Husky; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, Husky, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, Husky, name, ); }
    std::string bark() override { PYBIND11_OVERRIDE(std::string, Husky, bark, ); }
};
</code></pre>
<p>我们可以使用模板辅助类将简化这类重复的绑定工作，这对有多个虚函数的基类尤其有用：</p>
<pre><code class="language-c++">template &lt;class AnimalBase = Animal&gt; class PyAnimal : public AnimalBase {
public:
    using AnimalBase::AnimalBase; // Inherit constructors
    std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE(std::string, AnimalBase, go, n_times); }
    std::string name() override { PYBIND11_OVERRIDE(std::string, AnimalBase, name, ); }
};
template &lt;class DogBase = Dog&gt; class PyDog : public PyAnimal&lt;DogBase&gt; {
public:
    using PyAnimal&lt;DogBase&gt;::PyAnimal; // Inherit constructors
    // Override PyAnimal's pure virtual go() with a non-pure one:
    std::string go(int n_times) override { PYBIND11_OVERRIDE(std::string, DogBase, go, n_times); }
    std::string bark() override { PYBIND11_OVERRIDE(std::string, DogBase, bark, ); }
};
</code></pre>
<p>这样，我们只需要一个辅助方法来定义虚函数和纯虚函数的重载了。只是这样编译器就需要生成许多额外的方法和类。</p>
<p>下面我们在pybind11中注册这些类：</p>
<pre><code class="language-c++">py::class_&lt;Animal, PyAnimal&lt;&gt;&gt; animal(m, &quot;Animal&quot;);
py::class_&lt;Dog, Animal, PyDog&lt;&gt;&gt; dog(m, &quot;Dog&quot;);
py::class_&lt;Husky, Dog, PyDog&lt;Husky&gt;&gt; husky(m, &quot;Husky&quot;);
// ... add animal, dog, husky definitions
</code></pre>
<p>注意，Husky不需要一个专门的辅助类，因为它没定义任何新的虚函数和纯虚函数的重载。</p>
<p>Python中的使用示例：</p>
<pre><code class="language-python">class ShihTzu(Dog):
    def bark(self):
        return &quot;yip!&quot;
</code></pre>
<h3 id="83-扩展跳板类的功能"><a class="header" href="#83-扩展跳板类的功能">8.3 扩展跳板类的功能</a></h3>
<h4 id="831-跳板类的初始化"><a class="header" href="#831-跳板类的初始化">8.3.1 跳板类的初始化</a></h4>
<p>默认情况下，跳板类需要的时候才初始化，即当一个Python类继承了绑定的C++类时（而不是创建绑定类的实例时），或者注册的构造函数仅对跳板类而非注册类有效时。这主要是处于性能的考量：如果只有虚函数需要跳板类时，不初始化跳板类可以避免运行时检查Python继承类是否有重载函数，以提高性能。</p>
<p>有时，将跳板类作为一个不仅仅用于处理虚函数分发的中间类来初始化还是有用的。例如，这个类可以执行额外的初始化操作，额外的析构操作，定义属性或方法来给类提供类似Python风格的接口。</p>
<p>要让pybind11在创建类实例时，总是初始化跳板类，类的构造函数需要使用<code>py::init_alias&lt;Args, ...&gt;()</code>来代替<code>py::init&lt;Args, ...&gt;()</code>。这样可以强制通过跳板类来构造，确保类成员的初始化和析构。</p>
<blockquote>
<p><strong>See also</strong>：See the file <code>tests/test_virtual_functions.cpp</code> for complete examples showing both normal and forced trampoline instantiation.</p>
</blockquote>
<h4 id="差异化函数签名"><a class="header" href="#差异化函数签名">差异化函数签名</a></h4>
<p>第一节中介绍的宏可以覆盖绝大多数公开C++类的场景。有时，我们难以创建参数和返回类型间的一一映射关系。如C++的参数即是输入又是输出的情况（入参为引用，在函数中修改该参数）。</p>
<p>我们可以通过跳板类来解决这种Python方法输入和输出的问题，也可以参考 <a href="https://pybind11.readthedocs.io/en/stable/faq.html#faq-reference-arguments">Limitations involving reference arguments</a>中的处理方法。</p>
<p><code>get_override()</code>函数允许Python从跳板类方法中检索方法的实现。Consider for example a C++ method which has the signature <code>bool myMethod(int32_t&amp; value)</code>, where the return indicates whether something should be done with the <code>value</code>. This can be made convenient on the Python side by allowing the Python function to return <code>None</code> or an <code>int</code>:</p>
<pre><code class="language-c++">bool MyClass::myMethod(int32_t&amp; value)
{
    pybind11::gil_scoped_acquire gil;  // Acquire the GIL while in this scope.
    // Try to look up the overridden method on the Python side.
    pybind11::function override = pybind11::get_override(this, &quot;myMethod&quot;);
    if (override) {  // method is found
        auto obj = override(value);  // Call the Python function.
        if (py::isinstance&lt;py::int_&gt;(obj)) {  // check if it returned a Python integer type
            value = obj.cast&lt;int32_t&gt;();  // Cast it and assign it to the value.
            return true;  // Return true; value should be used.
        } else {
            return false;  // Python returned none, return false.
        }
    }
    return false;  // Alternatively return MyClass::myMethod(value);
}
</code></pre>
<h3 id="84-定制构造函数"><a class="header" href="#84-定制构造函数">8.4 定制构造函数</a></h3>
<p>前面章节介绍了绑定构造函数的方法，但它仅仅在C++侧刚好有对应的函数时才能正常工作。为了扩展到更通用的情况，pybind11可以绑定工厂方法作为构造函数。如下所示：</p>
<pre><code class="language-c++">class Example {
private:
    Example(int); // private constructor
public:
    // Factory function:
    static Example create(int a) { return Example(a); }
};

py::class_&lt;Example&gt;(m, &quot;Example&quot;)
    .def(py::init(&amp;Example::create));
</code></pre>
<p>虽然可以直接绑定<code>create</code>方法，有时将其在Python侧将其作为构造函数公开更为合适。这可以通过调用<code>.def(py::init(...))</code>来完成，只需将对应的函数（返回一个新实例，如create）作为参数传入<code>py::init()</code>即可。同样的，用这个方法我们也可以传入一个函数，它返回新实例的原始指针或持有者（如``std::unique_ptr`）。如下所示：</p>
<pre><code class="language-c++">class Example {
private:
    Example(int); // private constructor
public:
    // Factory function - returned by value:
    static Example create(int a) { return Example(a); }

    // These constructors are publicly callable:
    Example(double);
    Example(int, int);
    Example(std::string);
};

py::class_&lt;Example&gt;(m, &quot;Example&quot;)
    // Bind the factory function as a constructor:
    .def(py::init(&amp;Example::create))
    // Bind a lambda function returning a pointer wrapped in a holder:
    .def(py::init([](std::string arg) {
        return std::unique_ptr&lt;Example&gt;(new Example(arg));
    }))
    // Return a raw pointer:
    .def(py::init([](int a, int b) { return new Example(a, b); }))
    // You can mix the above with regular C++ constructor bindings as well:
    .def(py::init&lt;double&gt;())
    ;
</code></pre>
<p>当Python侧调用这些构造函数时，pybind11将调用工厂函数，并将返回的C++示例存储到Python实例中。</p>
<p>当与重载函数跳板类结合使用时，有两种方法。第一种方法是跳板类增加一个构造函数，函数接受原类的右值引用，这样我们可以从原类的工厂函数构造跳板类的实例。第二种方法是使用<code>py::init()</code>提供原类和跳板类两个工厂函数。</p>
<p>你也可以指定一个工厂函数，它总是返回跳板类的实例，这与<code>py::init_alias&lt;...&gt;</code>的行为类似。</p>
<p>下面的示例展示了这两种方法：</p>
<pre><code class="language-c++">#include &lt;pybind11/factory.h&gt;
class Example {
public:
    // ...
    virtual ~Example() = default;
};
class PyExample : public Example {
public:
    using Example::Example;
    PyExample(Example &amp;&amp;base) : Example(std::move(base)) {}
};
py::class_&lt;Example, PyExample&gt;(m, &quot;Example&quot;)
    // Returns an Example pointer.  If a PyExample is needed, the Example
    // instance will be moved via the extra constructor in PyExample, above.
    .def(py::init([]() { return new Example(); }))
    // Two callbacks:
    .def(py::init([]() { return new Example(); } /* no alias needed */,
                  []() { return new PyExample(); } /* alias needed */))
    // *Always* returns an alias instance (like py::init_alias&lt;&gt;())
    .def(py::init([]() { return new PyExample(); }))
    ;
</code></pre>
<h4 id="大括号初始化"><a class="header" href="#大括号初始化">大括号初始化</a></h4>
<p><code>pybind11</code>潜在地使用C++11的大括号初始化来调用目标类的构造函数，这意味着它也可以绑定隐式的构造函数：</p>
<pre><code class="language-c++">struct Aggregate {
    int a;
    std::string b;
};

py::class_&lt;Aggregate&gt;(m, &quot;Aggregate&quot;)
    .def(py::init&lt;int, const std::string &amp;&gt;());
</code></pre>
<blockquote>
<p>Note: 大括号初始化优先匹配带列表初始化的重载构造函数。极少数情况下会出问题，你可以使用<code>py::init(...)</code>传入一个构造新对象的匿名函数来处理这个问题。</p>
</blockquote>
<h3 id="85-非公有析构函数"><a class="header" href="#85-非公有析构函数">8.5 非公有析构函数</a></h3>
<p>如果一个类拥有私有或保护的析构函数（例如单例类），通过pybind11绑定类时编译器将会报错。本质的问题是<code>std::unique_ptr</code>智能指针负责管理实例的生命周期需要引用析构函数，即便没有资源需要回收。Pybind11提供了辅助类<code>py::nodelete</code>来禁止对析构函数的调用。这种情况下，C++侧负责析构对象避免内存泄漏就十分重要。</p>
<pre><code class="language-c++">/* ... definition ... */

class MyClass {
private:
    ~MyClass() { }
};

/* ... binding code ... */

py::class_&lt;MyClass, std::unique_ptr&lt;MyClass, py::nodelete&gt;&gt;(m, &quot;MyClass&quot;)
    .def(py::init&lt;&gt;())
</code></pre>
<h3 id="86-在析构函数中调用python"><a class="header" href="#86-在析构函数中调用python">8.6 在析构函数中调用Python</a></h3>
<p>在析构函数中调用Python函数出错时，会抛出异常<code>error_already_set</code>。如果异常在析构函数外抛出，将会调用<code>std::terminate()</code>来终结程序。因此，类析构函数必须捕获所有<code>error_already_set</code>类型的异常，并使用<code>error_already_set::discard_as_unraisable()</code>来丢弃Python异常。</p>
<p>任意Python函数都可能抛出异常。比如一个Python生成器停止生成条目时，Pyhton将抛出<code>StopIteration</code>异常，如果生成器的堆栈持有C++对象的最后一个引用时，它将传递异常到C++析构函数。</p>
<pre><code class="language-c++">class MyClass {
public:
    ~MyClass() {
        try {
            py::print(&quot;Even printing is dangerous in a destructor&quot;);
            py::exec(&quot;raise ValueError('This is an unraisable exception')&quot;);
        } catch (py::error_already_set &amp;e) {
            // error_context should be information about where/why the occurred,
            // e.g. use __func__ to get the name of the current function
            e.discard_as_unraisable(__func__);
        }
    }
};
</code></pre>
<blockquote>
<p>Note: pybind11不支持将C++析构函数标识为<code>noexcept(false)</code>。</p>
</blockquote>
<h3 id="87-隐式转换"><a class="header" href="#87-隐式转换">8.7 隐式转换</a></h3>
<p>假设有A和B两个类，A可以直接转换为B。</p>
<pre><code class="language-c++">py::class_&lt;A&gt;(m, &quot;A&quot;)
    /// ... members ...

py::class_&lt;B&gt;(m, &quot;B&quot;)
    .def(py::init&lt;A&gt;())
    /// ... members ...

m.def(&quot;func&quot;,
    [](const B &amp;) { /* .... */ }
);
</code></pre>
<p>如果想func函数传入A类型的参数a，Pyhton侧需要这样写<code>func(B(a))</code>，而C++则可以直接使用<code>func(a)</code>，自动将A类型转换为B类型。</p>
<p>这种情形下（B有一个接受A类型参数的构造函数），我们可以使用如下声明来让Python侧也支持类似的隐式转换：</p>
<pre><code class="language-c++">py::implicitly_convertible&lt;A, B&gt;();
</code></pre>
<blockquote>
<p>Note: A到B的隐式转换仅在通过pybind11绑定了B类型的条件下有效。</p>
<p>为了防止失控的递归调用，隐式转换时不可重入的：an implicit conversion invoked as part of another implicit conversion of the same type (i.e. from <code>A</code> to <code>B</code>) will fail.</p>
</blockquote>
<h3 id="88-静态属性"><a class="header" href="#88-静态属性">8.8 静态属性</a></h3>
<p>静态属性也可以像普通属性一样公开getter和setter方法。隐式的self参数仍然存在，并在Python中用于传递Python<code>type</code>子类实例。我们通常在C++侧忽略这个参数，下面的例子演示了如何使用lambda表达式做为getter函数，并忽略self参数。</p>
<pre><code class="language-c++">py::class_&lt;Foo&gt;(m, &quot;Foo&quot;)
    .def_property_readonly_static(&quot;foo&quot;, [](py::object /* self */) { return Foo(); });
</code></pre>
<h3 id="89-重载操作符"><a class="header" href="#89-重载操作符">8.9 重载操作符</a></h3>
<p>假设有这样一个类<code>Vector2</code>，它通过重载操作符实现了向量加法和标量乘法。</p>
<pre><code class="language-c++">class Vector2 {
public:
    Vector2(float x, float y) : x(x), y(y) { }

    Vector2 operator+(const Vector2 &amp;v) const { return Vector2(x + v.x, y + v.y); }
    Vector2 operator*(float value) const { return Vector2(x * value, y * value); }
    Vector2&amp; operator+=(const Vector2 &amp;v) { x += v.x; y += v.y; return *this; }
    Vector2&amp; operator*=(float v) { x *= v; y *= v; return *this; }

    friend Vector2 operator*(float f, const Vector2 &amp;v) {
        return Vector2(f * v.x, f * v.y);
    }

    std::string toString() const {
        return &quot;[&quot; + std::to_string(x) + &quot;, &quot; + std::to_string(y) + &quot;]&quot;;
    }
private:
    float x, y;
};
</code></pre>
<p>操作符绑定代码如下：</p>
<pre><code class="language-c++">#include &lt;pybind11/operators.h&gt;

PYBIND11_MODULE(example, m) {
    py::class_&lt;Vector2&gt;(m, &quot;Vector2&quot;)
        .def(py::init&lt;float, float&gt;())
        .def(py::self + py::self)
        .def(py::self += py::self)
        .def(py::self *= float())
        .def(float() * py::self)
        .def(py::self * float())
        .def(-py::self)
        .def(&quot;__repr__&quot;, &amp;Vector2::toString);
}
</code></pre>
<p><code>.def(py::self * float())</code>是如下代码的简短标记：</p>
<pre><code class="language-c++">.def(&quot;__mul__&quot;, [](const Vector2 &amp;a, float b) {
    return a * b;
}, py::is_operator())
</code></pre>
<h3 id="810-支持pickle"><a class="header" href="#810-支持pickle">8.10 支持pickle</a></h3>
<p>Python的<code>pickle</code>模块提供了强大的将Python对象图到二进制数据流的序列化和反序列化的功能。pybind11也提供了<code>py::pickle()</code>定义来支持pickle和unpickle C++类。现在有这样一个类：</p>
<pre><code class="language-c++">class Pickleable {
public:
    Pickleable(const std::string &amp;value) : m_value(value) { }
    const std::string &amp;value() const { return m_value; }

    void setExtra(int extra) { m_extra = extra; }
    int extra() const { return m_extra; }
private:
    std::string m_value;
    int m_extra = 0;
};
</code></pre>
<p>Python中通过定义<code>__setstate__</code>和<code>__getstate__</code>使能pciking支持。对于pybind11类，可以使用<code>py::pickle()</code>来绑定这两个函数：</p>
<pre><code class="language-c++">py::class_&lt;Pickleable&gt;(m, &quot;Pickleable&quot;)
    .def(py::init&lt;std::string&gt;())
    .def(&quot;value&quot;, &amp;Pickleable::value)
    .def(&quot;extra&quot;, &amp;Pickleable::extra)
    .def(&quot;setExtra&quot;, &amp;Pickleable::setExtra)
    .def(py::pickle(
        [](const Pickleable &amp;p) { // __getstate__
            /* Return a tuple that fully encodes the state of the object */
            return py::make_tuple(p.value(), p.extra());
        },
        [](py::tuple t) { // __setstate__
            if (t.size() != 2)
                throw std::runtime_error(&quot;Invalid state!&quot;);

            /* Create a new C++ instance */
            Pickleable p(t[0].cast&lt;std::string&gt;());

            /* Assign any additional state */
            p.setExtra(t[1].cast&lt;int&gt;());

            return p;
        }
    ));
</code></pre>
<p><code>py::pickle()</code>中的<code>__setstate__</code>部分遵循与<code>py::init()</code>单参数版本相同的规则，返回值可以是一个值，指针或者holder type。</p>
<p>Python中使用示例如下：</p>
<pre><code class="language-python">try:
    import cPickle as pickle  # Use cPickle on Python 2.7
except ImportError:
    import pickle

p = Pickleable(&quot;test_value&quot;)
p.setExtra(15)
data = pickle.dumps(p, 2)
</code></pre>
<blockquote>
<p>Note: Note that only the cPickle module is supported on Python 2.7.</p>
<p>The second argument to <code>dumps</code> is also crucial: it selects the pickle protocol version 2, since the older version 1 is not supported. Newer versions are also fine—for instance, specify <code>-1</code> to always use the latest available version. Beware: failure to follow these instructions will cause important pybind11 memory allocation routines to be skipped during unpickling, which will likely lead to memory corruption and/or segmentation faults.</p>
</blockquote>
<h3 id="811-深拷贝支持"><a class="header" href="#811-深拷贝支持">8.11 深拷贝支持</a></h3>
<p>Python通常在赋值中使用引用。有时需要一个真正的拷贝，以防止修改所有的拷贝实例。Python的<code>copy</code>模块提供了这样的拷贝能力。</p>
<p>在Python3中，带pickle支持的类自带深拷贝能力。但是，自定义<code>__copy__</code>和<code>__deepcopy__</code>方法能够提高拷贝的性能。在Python2.7中，由于pybind11只支持cPickle，要想实现深拷贝，用户必须实现这个两个方法。</p>
<p>对于一些简单的类，可以使用拷贝构造函数来实现深拷贝。如下所示：</p>
<pre><code class="language-c++">py::class_&lt;Copyable&gt;(m, &quot;Copyable&quot;)
    .def(&quot;__copy__&quot;,  [](const Copyable &amp;self) {
        return Copyable(self);
    })
    .def(&quot;__deepcopy__&quot;, [](const Copyable &amp;self, py::dict) {
        return Copyable(self);
    }, &quot;memo&quot;_a);
</code></pre>
<blockquote>
<p>Note: 本例中不会复制动态属性。</p>
</blockquote>
<h3 id="812-多重继承"><a class="header" href="#812-多重继承">8.12 多重继承</a></h3>
<p>pybind11支持绑定多重继承的类，只需在将所有基类作为<code>class_</code>的模板参数即可：</p>
<pre><code class="language-c++">py::class_&lt;MyType, BaseType1, BaseType2, BaseType3&gt;(m, &quot;MyType&quot;)
   ...
</code></pre>
<p>基类间的顺序任意，甚至可以穿插使用别名或者holder类型，pybind11能够自动识别它们。唯一的要求就是第一个模板参数必须是类型本身。</p>
<p>允许Python中定义的类继承多个C++类，也允许混合继承C++类和Python类。</p>
<p>有一个关于该特性实现的警告：当仅指定一个基类，实际上有多个基类时，pybind11会认为它并没有使用多重继承，这将导致未定义行为。对于这个问题，我们可以在类构造函数中添加<code>multiple_inheritance</code>的标识。</p>
<pre><code class="language-c++">py::class_&lt;MyType, BaseType2&gt;(m, &quot;MyType&quot;, py::multiple_inheritance());
</code></pre>
<p>当模板参数列出了多个基类时，无需使用该标识。</p>
<h3 id="813-绑定module-local类"><a class="header" href="#813-绑定module-local类">8.13 绑定Module-local类</a></h3>
<p>pybind11默认将类绑定到模块的全局作用域中。这意味着模块中定义的类型，可能获得其他模块中相同类型名的结果。示例如下：</p>
<pre><code class="language-c++">// In the module1.cpp binding code for module1:
py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)
    .def(py::init&lt;std::string&gt;())
    .def_readonly(&quot;name&quot;, &amp;Pet::name);

// In the module2.cpp binding code for module2:
m.def(&quot;create_pet&quot;, [](std::string name) { return new Pet(name); });
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; from module1 import Pet
&gt;&gt;&gt; from module2 import create_pet
&gt;&gt;&gt; pet1 = Pet(&quot;Kitty&quot;)
&gt;&gt;&gt; pet2 = create_pet(&quot;Doggy&quot;)
&gt;&gt;&gt; pet2.name()
'Doggy'
</code></pre>
<p>有时，我们希望将一个复杂的库分割到几个Python模块中。</p>
<p>在某些例子中，这也会引起冲突。例如，有两个不相干的模块使用了同一个C++外部库，而且他们各自提供了这个库的自定义绑定。当Python程序同时（直接或间接地）导入两个库时，由于外部类型的定义冲突而导致错误。</p>
<pre><code class="language-c++">// dogs.cpp

// Binding for external library class:
py::class&lt;pets::Pet&gt;(m, &quot;Pet&quot;)
    .def(&quot;name&quot;, &amp;pets::Pet::name);

// Binding for local extension class:
py::class&lt;Dog, pets::Pet&gt;(m, &quot;Dog&quot;)
    .def(py::init&lt;std::string&gt;());
</code></pre>
<pre><code class="language-c++">// cats.cpp, in a completely separate project from the above dogs.cpp.

// Binding for external library class:
py::class&lt;pets::Pet&gt;(m, &quot;Pet&quot;)
    .def(&quot;get_name&quot;, &amp;pets::Pet::name);

// Binding for local extending class:
py::class&lt;Cat, pets::Pet&gt;(m, &quot;Cat&quot;)
    .def(py::init&lt;std::string&gt;());
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; import cats
&gt;&gt;&gt; import dogs
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ImportError: generic_type: type &quot;Pet&quot; is already registered!
</code></pre>
<p>为避开这点，你可以想<code>py::class_</code>传递<code>py::module_local()</code>属性，将外部类绑定到模块内部。</p>
<pre><code class="language-c++">// Pet binding in dogs.cpp:
py::class&lt;pets::Pet&gt;(m, &quot;Pet&quot;, py::module_local())
    .def(&quot;name&quot;, &amp;pets::Pet::name);
</code></pre>
<pre><code class="language-c++">// Pet binding in cats.cpp:
py::class&lt;pets::Pet&gt;(m, &quot;Pet&quot;, py::module_local())
    .def(&quot;get_name&quot;, &amp;pets::Pet::name);
</code></pre>
<p>这样，Python侧的<code>dogs.Pet</code>和<code>cats.Pet</code>就是两个不同的类，两个模块也能顺利地同时导入，互不干扰。有两点需要注意的是：1）外部模块不能返回或转换<code>Pet</code>示例到Python（除非他们也提供自己内部的绑定）；2）在Python的视角来看，他们就是两个截然不同的类。</p>
<p>注意，这个局部性仅作用于C++到Python方向。传递一个<code>py::module_local</code>类型到C++函数，在module-local类看来仍是合理的。这意味着，下面的函数添加到任意哪个模块（不限于cats和dogs两个模块），它将可以通过<code>dogs.Pet</code>或<code>cats.Pet</code>参数来调用。</p>
<pre><code class="language-c++">m.def(&quot;pet_name&quot;, [](const pets::Pet &amp;pet) { return pet.name(); });
</code></pre>
<p>举个例子，假设上述函数被添加到<code>cats.cpp</code>，<code>dogs.cpp</code>和<code>frogs.cpp</code>（<code>frogs.cpp</code>没有绑定<code>Pets</code>类）。</p>
<pre><code class="language-python">&gt;&gt;&gt; import cats, dogs, frogs  # No error because of the added py::module_local()
&gt;&gt;&gt; mycat, mydog = cats.Cat(&quot;Fluffy&quot;), dogs.Dog(&quot;Rover&quot;)
&gt;&gt;&gt; (cats.pet_name(mycat), dogs.pet_name(mydog))
('Fluffy', 'Rover')
&gt;&gt;&gt; (cats.pet_name(mydog), dogs.pet_name(mycat), frogs.pet_name(mycat))
('Rover', 'Fluffy', 'Fluffy')
</code></pre>
<p>即便其他模块已经全局地注册了相同的类型，我们还是可以使用<code>py::module_local()</code>来注册到另一个模块：在module-local定义的模块，所有C++势力将被转为关联的Python类型。在其他模块，这个实例则被转为全局地Python类型。</p>
<blockquote>
<p>Note: STL bindings (as provided via the optional <code>pybind11/stl_bind.h</code> header) apply <code>py::module_local</code> by default when the bound type might conflict with other modules; see <a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#stl-bind">Binding STL containers</a> for details.</p>
<p>The localization of the bound types is actually tied to the shared object or binary generated by the compiler/linker. For typical modules created with <code>PYBIND11_MODULE()</code>, this distinction is not significant. It is possible, however, when <a href="https://pybind11.readthedocs.io/en/stable/advanced/embedding.html#embedding">Embedding the interpreter</a> to embed multiple modules in the same binary (see <a href="https://pybind11.readthedocs.io/en/stable/advanced/embedding.html#embedding-modules">Adding embedded modules</a>). In such a case, the localization will apply across all embedded modules within the same binary.</p>
</blockquote>
<h3 id="8-14-绑定protected成员函数"><a class="header" href="#8-14-绑定protected成员函数">8. 14 绑定protected成员函数</a></h3>
<p>通常不可能向Python公开protected 成员函数：</p>
<pre><code class="language-c++">class A {
protected:
    int foo() const { return 42; }
};

py::class_&lt;A&gt;(m, &quot;A&quot;)
    .def(&quot;foo&quot;, &amp;A::foo); // error: 'foo' is a protected member of 'A'
</code></pre>
<p>因为非公有成员函数意味着外部不可调用。但我们还是希望在Python派生类中使用protected 函数。我们可以通过下面的方式来实现：</p>
<pre><code class="language-c++">class A {
protected:
    int foo() const { return 42; }
};

class Publicist : public A { // helper type for exposing protected functions
public:
    using A::foo; // inherited with different access modifier
};

py::class_&lt;A&gt;(m, &quot;A&quot;) // bind the primary class
    .def(&quot;foo&quot;, &amp;Publicist::foo); // expose protected methods via the publicist
</code></pre>
<p>因为 <code>&amp;Publicist::foo</code> 和<code>&amp;A::foo</code> 准确地说是同一个函数（相同的签名和地址），仅仅是获取方式不同。 <code>Publicist</code> 的唯一意图，就是将函数的作用域变为<code>public</code>。</p>
<p>如果是希望公开在Python侧重载的 <code>protected</code>虚函数，可以将publicist pattern与之前提到的trampoline相结合：</p>
<pre><code class="language-c++">class A {
public:
    virtual ~A() = default;

protected:
    virtual int foo() const { return 42; }
};

class Trampoline : public A {
public:
    int foo() const override { PYBIND11_OVERRIDE(int, A, foo, ); }
};

class Publicist : public A {
public:
    using A::foo;
};

py::class_&lt;A, Trampoline&gt;(m, &quot;A&quot;) // &lt;-- `Trampoline` here
    .def(&quot;foo&quot;, &amp;Publicist::foo); // &lt;-- `Publicist` here, not `Trampoline`!
</code></pre>
<h3 id="815-绑定final类"><a class="header" href="#815-绑定final类">8.15 绑定final类</a></h3>
<p>在C++11中，我们可以使用<code>findal</code>关键字来确保一个类不被继承。<code>py::is_final</code>属性则可以用来确保一个类在Python中不被继承。底层的C++类型不需要定义为final。</p>
<pre><code class="language-c++">class IsFinal final {};

py::class_&lt;IsFinal&gt;(m, &quot;IsFinal&quot;, py::is_final());
</code></pre>
<p>在Python中试图继承这个类，将导致错误：</p>
<pre><code class="language-python">class PyFinalChild(IsFinal):
    pass

TypeError: type 'IsFinal' is not an acceptable base type
</code></pre>
<h3 id="816-定制自动向下转型"><a class="header" href="#816-定制自动向下转型">8.16 定制自动向下转型</a></h3>
<p>如前面“继承与自动转型”一节中解释的，pybind11内置了对C++多态的动态类型的处理。Sometimes, you might want to provide this automatic downcasting behavior when creating bindings for a class hierarchy that does not use standard C++ polymorphism, such as LLVM. As long as there’s some way to determine at runtime whether a downcast is safe, you can proceed by specializing the <code>pybind11::polymorphic_type_hook</code> template:</p>
<pre><code class="language-c++">enum class PetKind { Cat, Dog, Zebra };
struct Pet {   // Not polymorphic: has no virtual methods
    const PetKind kind;
    int age = 0;
  protected:
    Pet(PetKind _kind) : kind(_kind) {}
};
struct Dog : Pet {
    Dog() : Pet(PetKind::Dog) {}
    std::string sound = &quot;woof!&quot;;
    std::string bark() const { return sound; }
};

namespace pybind11 {
    template&lt;&gt; struct polymorphic_type_hook&lt;Pet&gt; {
        static const void *get(const Pet *src, const std::type_info*&amp; type) {
            // note that src may be nullptr
            if (src &amp;&amp; src-&gt;kind == PetKind::Dog) {
                type = &amp;typeid(Dog);
                return static_cast&lt;const Dog*&gt;(src);
            }
            return src;
        }
    };
} // namespace pybind11
</code></pre>
<p>When pybind11 wants to convert a C++ pointer of type <code>Base*</code> to a Python object, it calls <code>polymorphic_type_hook&lt;Base&gt;::get()</code> to determine if a downcast is possible. The <code>get()</code> function should use whatever runtime information is available to determine if its <code>src</code> parameter is in fact an instance of some class <code>Derived</code> that inherits from <code>Base</code>. If it finds such a <code>Derived</code>, it sets <code>type = &amp;typeid(Derived)</code> and returns a pointer to the <code>Derived</code> object that contains <code>src</code>. Otherwise, it just returns <code>src</code>, leaving <code>type</code> at its default value of nullptr. If you set <code>type</code> to a type that pybind11 doesn’t know about, no downcasting will occur, and the original <code>src</code> pointer will be used with its static type <code>Base*</code>.</p>
<p>It is critical that the returned pointer and <code>type</code> argument of <code>get()</code> agree with each other: if <code>type</code> is set to something non-null, the returned pointer must point to the start of an object whose type is <code>type</code>. If the hierarchy being exposed uses only single inheritance, a simple <code>return src;</code> will achieve this just fine, but in the general case, you must cast <code>src</code> to the appropriate derived-class pointer (e.g. using <code>static_cast&lt;Derived&gt;(src)</code>) before allowing it to be returned as a <code>void*</code>.</p>
<h3 id="817-访问类型对象"><a class="header" href="#817-访问类型对象">8.17 访问类型对象</a></h3>
<p>我们可以从已注册的C++类，获取到类型对象：</p>
<pre><code class="language-c++">py::type T_py = py::type::of&lt;T&gt;();
</code></pre>
<p>也可以直接使用<code>py::type::of(ob)</code>来获取任意Python对象的类型，跟Python中的<code>type(ob)</code>一样。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="9-异常"><a class="header" href="#9-异常">9. 异常</a></h2>
<h3 id="91-c内置异常到python异常的转换"><a class="header" href="#91-c内置异常到python异常的转换">9.1 C++内置异常到Python异常的转换</a></h3>
<p>当Python通过pybind11调用C++代码时，pybind11将捕获C++异常，并将其翻译为对应的Python异常后抛出。这样Python代码就能够处理它们。</p>
<p>pybind11定义了<code>std::exception</code>及其标准子类，和一些特殊异常到Python异常的翻译。由于它们不是真正的Python异常，所以不能使用Python C API来检查。相反，它们是纯C++异常，当它们到达异常处理器时，pybind11将其翻译为对应的Python异常。</p>
<div class="table-wrapper"><table><thead><tr><th>Exception thrown by C++</th><th>Translated to Python exception type</th></tr></thead><tbody>
<tr><td><code>std::exception</code></td><td><code>RuntimeError</code></td></tr>
<tr><td><code>std::bad_alloc</code></td><td><code>MemoryError</code></td></tr>
<tr><td><code>std::domain_error</code></td><td><code>ValueError</code></td></tr>
<tr><td><code>std::invalid_argument</code></td><td><code>ValueError</code></td></tr>
<tr><td><code>std::length_error</code></td><td><code>ValueError</code></td></tr>
<tr><td><code>std::out_of_range</code></td><td><code>IndexError</code></td></tr>
<tr><td><code>std::range_error</code></td><td><code>ValueError</code></td></tr>
<tr><td><code>std::overflow_error</code></td><td><code>OverflowError</code></td></tr>
<tr><td><code>pybind11::stop_iteration</code></td><td><code>StopIteration</code> (used to implement custom iterators)</td></tr>
<tr><td><code>pybind11::index_error</code></td><td><code>IndexError</code> (used to indicate out of bounds access in <code>__getitem__</code>, <code>__setitem__</code>, etc.)</td></tr>
<tr><td><code>pybind11::key_error</code></td><td><code>KeyError</code> (used to indicate out of bounds access in <code>__getitem__</code>, <code>__setitem__</code> in dict-like objects, etc.)</td></tr>
<tr><td><code>pybind11::value_error</code></td><td><code>ValueError</code> (used to indicate wrong value passed in <code>container.remove(...)</code>)</td></tr>
<tr><td><code>pybind11::type_error</code></td><td><code>TypeError</code></td></tr>
<tr><td><code>pybind11::buffer_error</code></td><td><code>BufferError</code></td></tr>
<tr><td><code>pybind11::import_error</code></td><td><code>ImportError</code></td></tr>
<tr><td><code>pybind11::attribute_error</code></td><td><code>AttributeError</code></td></tr>
<tr><td>Any other exception</td><td><code>RuntimeError</code></td></tr>
</tbody></table>
</div>
<p>异常翻译不是双向的。即上述异常不会捕获源自Python的异常。Python的异常，需要捕获<code>pybind11::error_already_set</code>。</p>
<p>这里有个特殊的异常，当入参不能转化为Python对象时，<code>handle::call()</code>将抛出<code>cast_error</code>异常。</p>
<h3 id="92-注册自定义异常翻译"><a class="header" href="#92-注册自定义异常翻译">9.2 注册自定义异常翻译</a></h3>
<p>如果上述默认异常转换策略不够用，pybind11也提供了注册自定义异常翻译的支持。类似于pybind11 class，异常翻译也可以定义在模块内或global。要注册一个使用C++异常的<code>what()</code>方法将C++到Python的异常转换，可以使用下面的方法：</p>
<pre><code class="language-c++">py::register_exception&lt;CppExp&gt;(module, &quot;PyExp&quot;);
</code></pre>
<p>这个调用在指定模块创建了一个名称为PyExp的Python异常，并自动将CppExp相关的异常转换为PyExp异常。</p>
<p>相似的函数可以注册模块内的异常翻译：</p>
<pre><code class="language-c++">py::register_local_exception&lt;CppExp&gt;(module, &quot;PyExp&quot;);
</code></pre>
<p>方法的第三个参数handle可以指定异常的基类：</p>
<pre><code class="language-c++">py::register_exception&lt;CppExp&gt;(module, &quot;PyExp&quot;, PyExc_RuntimeError);
py::register_local_exception&lt;CppExp&gt;(module, &quot;PyExp&quot;, PyExc_RuntimeError);
</code></pre>
<p>这样，PyExp异常可以捕获PyExp和RuntimeError。</p>
<p>Python内置的异常类型可以参考Python文档<a href="https://docs.python.org/3/c-api/exceptions.html#standard-exceptions">Standard Exceptions</a>，默认的基类为<code>PyExc_Exception</code>。</p>
<p><code>py::register_exception_translator(translator)</code> 和<code>py::register_local_exception_translator(translator)</code> 提供了更高级的异常翻译功能，它可以注册任意的异常类型。函数接受一个无状态的回调函数<code>void(std::exception_ptr)</code>。</p>
<p>C++异常抛出时，注册的异常翻译类将以注册时相反的顺序匹配，优先匹配模块内翻译类，然后再是全局翻译类。</p>
<p>Inside the translator, <code>std::rethrow_exception</code> should be used within a try block to re-throw the exception. One or more catch clauses to catch the appropriate exceptions should then be used with each clause using <code>PyErr_SetString</code> to set a Python exception or <code>ex(string)</code> to set the python exception to a custom exception type (see below).</p>
<p>To declare a custom Python exception type, declare a <code>py::exception</code> variable and use this in the associated exception translator (note: it is often useful to make this a static declaration when using it inside a lambda expression without requiring capturing).</p>
<p>The following example demonstrates this for a hypothetical exception classes <code>MyCustomException</code> and <code>OtherException</code>: the first is translated to a custom python exception <code>MyCustomError</code>, while the second is translated to a standard python RuntimeError:</p>
<pre><code>static py::exception&lt;MyCustomException&gt; exc(m, &quot;MyCustomError&quot;);
py::register_exception_translator([](std::exception_ptr p) {
    try {
        if (p) std::rethrow_exception(p);
    } catch (const MyCustomException &amp;e) {
        exc(e.what());
    } catch (const OtherException &amp;e) {
        PyErr_SetString(PyExc_RuntimeError, e.what());
    }
});
</code></pre>
<p>Multiple exceptions can be handled by a single translator, as shown in the example above. If the exception is not caught by the current translator, the previously registered one gets a chance.</p>
<p>If none of the registered exception translators is able to handle the exception, it is handled by the default converter as described in the previous section.</p>
<h3 id="93-local-vs-global-exception-translators"><a class="header" href="#93-local-vs-global-exception-translators">9.3 Local vs Global Exception Translators</a></h3>
<p>When a global exception translator is registered, it will be applied across all modules in the reverse order of registration. This can create behavior where the order of module import influences how exceptions are translated.</p>
<p>If module1 has the following translator:</p>
<pre><code>py::register_exception_translator([](std::exception_ptr p) {
  try {
      if (p) std::rethrow_exception(p);
  } catch (const std::invalid_argument &amp;e) {
      PyErr_SetString(&quot;module1 handled this&quot;)
  }
}
</code></pre>
<p>and module2 has the following similar translator:</p>
<pre><code>py::register_exception_translator([](std::exception_ptr p) {
  try {
      if (p) std::rethrow_exception(p);
  } catch (const std::invalid_argument &amp;e) {
      PyErr_SetString(&quot;module2 handled this&quot;)
  }
}
</code></pre>
<p>then which translator handles the invalid_argument will be determined by the order that module1 and module2 are imported. Since exception translators are applied in the reverse order of registration, which ever module was imported last will “win” and that translator will be applied.</p>
<p>If there are multiple pybind11 modules that share exception types (either standard built-in or custom) loaded into a single python instance and consistent error handling behavior is needed, then local translators should be used.</p>
<p>Changing the previous example to use <code>register_local_exception_translator</code> would mean that when invalid_argument is thrown in the module2 code, the module2 translator will always handle it, while in module1, the module1 translator will do the same.</p>
<h3 id="94-在c中处理python异常"><a class="header" href="#94-在c中处理python异常">9.4 在C++中处理Python异常</a></h3>
<p>当C++调用Python函数时（回调函数或者操作Python对象），若Python有异常抛出，pybind11会将Python异常转化为<code>pybind11::error_already_set</code>类型的异常，它包含了一个C++字符串描述和实际的Python异常。<code>error_already_set</code>用于将Python异常传回Python（或者在C++侧处理）。</p>
<div class="table-wrapper"><table><thead><tr><th>Exception raised in Python</th><th>Thrown as C++ exception type</th></tr></thead><tbody>
<tr><td>Any Python <code>Exception</code></td><td><code>pybind11::error_already_set</code></td></tr>
</tbody></table>
</div>
<p>举个例子：</p>
<pre><code class="language-c++">try {
    // open(&quot;missing.txt&quot;, &quot;r&quot;)
    auto file = py::module_::import(&quot;io&quot;).attr(&quot;open&quot;)(&quot;missing.txt&quot;, &quot;r&quot;);
    auto text = file.attr(&quot;read&quot;)();
    file.attr(&quot;close&quot;)();
} catch (py::error_already_set &amp;e) {
    if (e.matches(PyExc_FileNotFoundError)) {
        py::print(&quot;missing.txt not found&quot;);
    } else if (e.matches(PyExc_PermissionError)) {
        py::print(&quot;missing.txt found but not accessible&quot;);
    } else {
        throw;
    }
}
</code></pre>
<p>该方法并不适用与C++到Python的翻译，Python侧抛出的异常总是被翻译为<code>error_already_set</code>.</p>
<pre><code class="language-c++">try {
    py::eval(&quot;raise ValueError('The Ring')&quot;);
} catch (py::value_error &amp;boromir) {
    // Boromir never gets the ring
    assert(false);
} catch (py::error_already_set &amp;frodo) {
    // Frodo gets the ring
    py::print(&quot;I will take the ring&quot;);
}

try {
    // py::value_error is a request for pybind11 to raise a Python exception
    throw py::value_error(&quot;The ball&quot;);
} catch (py::error_already_set &amp;cat) {
    // cat won't catch the ball since
    // py::value_error is not a Python exception
    assert(false);
} catch (py::value_error &amp;dog) {
    // dog will catch the ball
    py::print(&quot;Run Spot run&quot;);
    throw;  // Throw it again (pybind11 will raise ValueError)
}
</code></pre>
<h3 id="95-处理python-c-api的错误"><a class="header" href="#95-处理python-c-api的错误">9.5 处理Python C API的错误</a></h3>
<p>尽可能地使用pybind11 wrappers代替直接调用Python C API。如果确实需要直接使用Python C API，除了需要手动管理引用计数外，还必须遵守pybind11的错误处理协议。</p>
<p>在调用Python C API后，如果Python返回错误，需要调用<code>throw py::error_already_set();</code>语句，让pybind11来处理异常并传递给Python解释器。这包括对错误设置函数的调用，如<code>PyErr_SetString</code>。</p>
<pre><code class="language-c++">PyErr_SetString(PyExc_TypeError, &quot;C API type error demo&quot;);
throw py::error_already_set();

// But it would be easier to simply...
throw py::type_error(&quot;pybind11 wrapper type error&quot;);
</code></pre>
<p>也可以调用<code>PyErr_Clear</code>来忽略错误。</p>
<p>任何Python错误必须被抛出或清除，否则Python/pybind11将处于无效的状态。</p>
<h3 id="96-异常链raise-from"><a class="header" href="#96-异常链raise-from">9.6 异常链（raise from）</a></h3>
<p>在Python 3.3中，引入了指示异常是由其他异常引发的机制：</p>
<pre><code class="language-python">try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError(&quot;could not divide by zero&quot;) from exc
</code></pre>
<p>pybind11 2.8版本，你可以使用<code>py::raise_from</code>函数来完成相同的事。它设置当前Python错误指示器，所以要继续传播异常，你应该<code>throw py::error_already_set()</code>（Python 3 only）。</p>
<pre><code class="language-c++">try {
    py::eval(&quot;print(1 / 0&quot;));
} catch (py::error_already_set &amp;e) {
    py::raise_from(e, PyExc_RuntimeError, &quot;could not divide by zero&quot;);
    throw py::error_already_set();
}
</code></pre>
<h3 id="97-处理unraiseable异常"><a class="header" href="#97-处理unraiseable异常">9.7 处理unraiseable异常</a></h3>
<p>如果Python调用的C++析构函数或任何标记为<code>noexcept(true)</code>的函数抛出了异常，该异常不会传播出去。如果它们在调用图中抛出或捕捉不到任何异常，c++运行时将调用std::terminate()立即终止程序。</p>
<p>类似的，在类<code>__del__</code>方法引发的Python异常也不会传播，但被Python作为unraisable错误记录下来。在Python 3.8+中，将触发system hook，并记录auditing event日志。</p>
<p>任何noexcept函数应该使用try-catch代码块来捕获<code>error_already_set</code>（或其他可能出现的异常）。pybind11包装的Python异常并非真正的Python异常，它是pybind11捕获并转化的C++异常。noexcept函数不能传播这些异常。我们可以将它们转换为Python异常，然后丢弃<code>discard_as_unraisable</code>，如下所示。</p>
<pre><code class="language-c++">void nonthrowing_func() noexcept(true) {
    try {
        // ...
    } catch (py::error_already_set &amp;eas) {
        // Discard the Python error using Python APIs, using the C++ magic
        // variable __func__. Python already knows the type and value and of the
        // exception object.
        eas.discard_as_unraisable(__func__);
    } catch (const std::exception &amp;e) {
        // Log and discard C++ exceptions.
        third_party::log(e);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="10-智能指针"><a class="header" href="#10-智能指针">10. 智能指针</a></h2>
<h3 id="101-stdunique_ptr"><a class="header" href="#101-stdunique_ptr">10.1 <code>std::unique_ptr</code></a></h3>
<p>给定一个带Python绑定的类<code>Example</code>，我们可以像下面一样返回它的unique pointer智能指针实例：</p>
<pre><code class="language-c++">std::unique_ptr&lt;Example&gt; create_example() { return std::unique_ptr&lt;Example&gt;(new Example()); }

m.def(&quot;create_example&quot;, &amp;create_example);
</code></pre>
<p>没其他需要特殊处理的地方。需要注意的是，虽然允许返回unique_ptr对象，但是将其作为函数入参是非法的。例如，pybind11不能处理下列函数签名。</p>
<pre><code class="language-c++">void do_something_with_example(std::unique_ptr&lt;Example&gt; ex) { ... }
</code></pre>
<p>上面的签名意味着Python需要放弃对象的所有权，并将其传递给该函数，这通常是不可能的（对象可能在别处被引用）。</p>
<h3 id="102-stdshared_ptr"><a class="header" href="#102-stdshared_ptr">10.2 <code>std::shared_ptr</code></a></h3>
<p><code>class_</code>可以传递一个表示持有者类型的模板类型，它用于管理对象的引用。在不指定的情况下，默认为<code>std::unique_ptr&lt;Type&gt;</code>类型，这意味着当Python的引用计数为0时，将析构对象。该模板类型可以指定为其他的智能指针或引用计数包装类，像下面我们就使用了<code>std::shared_ptr</code>：</p>
<pre><code class="language-c++">py::class_&lt;Example, std::shared_ptr&lt;Example&gt; /* &lt;- holder type */&gt; obj(m, &quot;Example&quot;);
</code></pre>
<p>注意，每个类仅能与一个持有者类型关联。</p>
<p>使用持有者类型的一个潜在的障碍就是，你需要始终如一的使用它们。猜猜下面的绑定代码有什么问题？</p>
<pre><code class="language-c++">class Child { };

class Parent {
public:
   Parent() : child(std::make_shared&lt;Child&gt;()) { }
   Child *get_child() { return child.get(); }  /* Hint: ** DON'T DO THIS ** */
private:
    std::shared_ptr&lt;Child&gt; child;
};

PYBIND11_MODULE(example, m) {
    py::class_&lt;Child, std::shared_ptr&lt;Child&gt;&gt;(m, &quot;Child&quot;);

    py::class_&lt;Parent, std::shared_ptr&lt;Parent&gt;&gt;(m, &quot;Parent&quot;)
       .def(py::init&lt;&gt;())
       .def(&quot;get_child&quot;, &amp;Parent::get_child);
}
</code></pre>
<p>下面的Python代码将导致未定义行为（类似段错误）。</p>
<pre><code class="language-python">from example import Parent
print(Parent().get_child())
</code></pre>
<p>问题在于<code>Parent::get_child()</code>返回类<code>Child</code>实例的指针，但事实上这个经由<code>std::shared_ptr&lt;...&gt;</code>管理的实例，在传递原始指针时就丢失了。这个例子中，pybind11将创建第二个独立的<code>std::shared_ptr&lt;...&gt;</code>声明指针的所有权。最后，对象将被free两次，因为两个shared指针没法知道彼此的存在。</p>
<p>有两种方法解决这个问题：</p>
<ol>
<li>
<p>对于智能指针管理的类型，永远不要在函数如参数或返回值中使用原始指针。换句话说，在任何需要使用该类型指针的地方，使用它们指定的持有者类型代替。这个例子中<code>get_child()</code>可以这样修改：</p>
<pre><code class="language-c++">std::shared_ptr&lt;Child&gt; get_child() { return child; }
</code></pre>
</li>
<li>
<p>定义<code>Child</code>时指定<code>std::enable_shared_from_this&lt;T&gt;</code>作为基类。这将在<code>Child</code>的基础上增加一点信息，让pybind11认识到这里已经存在一个<code>std::shared_ptr&lt;...&gt;</code>，并与之交互。修改示例如下：</p>
<pre><code class="language-c++">class Child : public std::enable_shared_from_this&lt;Child&gt; { };
</code></pre>
</li>
</ol>
<h3 id="103-自定义智能指针"><a class="header" href="#103-自定义智能指针">10.3 自定义智能指针</a></h3>
<p>pybind11支持开箱即用的 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 。对于其他自定义的智能指针，可以使用下面的宏使能透明转换（transparent conversions）。它必须在其他绑定代码之前在顶层名称空间中声明：</p>
<pre><code class="language-c++">PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr&lt;T&gt;);
</code></pre>
<p>宏的第一个参数为占位符名称，用作第二个参数的模板参数。因此，你可以使用任意的标识符（不要使用你的代码中已经存在的类型），只需保持两边一致即可。</p>
<p>宏也可以接收第三个可选的bool类型参数，默认为false。</p>
<pre><code class="language-c++">PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr&lt;T&gt;, true);
</code></pre>
<p>如果<code>SmartPtr&lt;T&gt;</code>总是从<code>T*</code>指针初始化，不存在不一致的风险（如多个独立的<code>SmartPtr&lt;T&gt;</code>认为他们是<code>T*</code>指针的唯一拥有者）。当<code>T</code>实例使用侵入式引用计数时，应设定为<code>true</code>。</p>
<p>在使用该特性前，请先阅读 <a href="https://pybind11.readthedocs.io/en/stable/advanced/misc.html#macro-notes">General notes regarding convenience macros</a>。</p>
<p>默认情况下，pybind11假定自定义智能指针具有标准接口，如提供<code>.get()</code>成员函数来获取底层的原始指针。如果没有，则需要指定<code>holder_helper</code>：</p>
<pre><code class="language-c++">// Always needed for custom holder types
PYBIND11_DECLARE_HOLDER_TYPE(T, SmartPtr&lt;T&gt;);

// Only needed if the type's `.get()` goes by another name
namespace pybind11 { namespace detail {
    template &lt;typename T&gt;
    struct holder_helper&lt;SmartPtr&lt;T&gt;&gt; { // &lt;-- specialization
        static const T *get(const SmartPtr&lt;T&gt; &amp;p) { return p.getPointer(); }
    };
}}
</code></pre>
<p>上述特化告诉pybind11，自定义<code>SmartPtr</code>通过<code>.getPointer()</code>提供<code>.get()</code>接口。</p>
<blockquote>
<p>see also: 文件<code>tests/test_smart_ptr.cpp</code>提供了一个展示如何使用自定义引用计数holder类型的详细示例。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="11-类型转换"><a class="header" href="#11-类型转换">11. 类型转换</a></h2>
<p>除了支持跨语言函数调用，pybind11这类绑定工具必须处理的一个基本问题就是，提供在C++中访问原生Python类型的方式，反之亦然。有三种完全不同的方法做到这点，每种方法适用性取决于你使用的环境。</p>
<ol>
<li>任意侧使用原生的C++类型。这种情况下，必须使用pybind11生成类型的绑定，Python才能使用它。</li>
<li>任意侧使用原生的Python类型。同样需要包装后，C++函数才能够使用它。</li>
<li>C++侧使用原生C++类型，Python侧使用原生Python类型。pybind11称其为类型转换。
某种意义下，在任意侧使用原生类型，类型转换是最自然的选项。该方法主要的缺点是，每次Python和C++之间转换时都需要拷贝一份数据，因为C++和Python的对相同类型的内存布局不一样。
pybind11可以自动完成多种类型的转换。后面会提供所有内置转换的表格。</li>
</ol>
<p>下面的小节将更详细地讨论这些选项之间的区别。</p>
<h3 id="111-概述"><a class="header" href="#111-概述">11.1 概述</a></h3>
<p><strong>1. Native type in C++, wrapper in Python</strong></p>
<p>在“面对对象编程”一章中，我们详细介绍了通过<code>py::class_</code>公开自定义C++类型的方法。这里，底层的数据结构仍然是原始的C++类，而<code>py::class_</code>包装则提供了Python侧的接口。当一个对象从C++侧发送到Python侧时，pybind11仅仅在原始的C++对象上增加了一层包装而已。从Python侧获取它也仅仅是撕掉了包装而已。</p>
<p><strong>2. Wrapper in C++, native type in Python</strong></p>
<p>这与上面是完全相反的情况。现在我们有一个原生的Python类型，如tuple或list。在C++侧获取这个数据的一种方法是使用<code>py::object</code>族包装器。这将在后续章节详细解释。这里举个简单的例子：</p>
<pre><code class="language-c++">void print_list(py::list my_list) {
    for (auto item : my_list)
        std::cout &lt;&lt; item &lt;&lt; &quot; &quot;;
}
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; print_list([1, 2, 3])
1 2 3
</code></pre>
<p>Python的list仅仅是包裹在了C++ <code>py::list</code>类里，并没有仅仅任何转换。它的核心任然是一个Python对象。拷贝一个<code>py::list</code>会像Python中一样增加引用计数。将对象返回到Python侧，将去掉这层封装。</p>
<p><strong>3. Converting between native C++ and Python types</strong></p>
<p>前面两种情况，我们在一种语言中使用原生类型，而在另一种语言中使用它的包装类型。现在，我们在两侧都使用原生类型，并对他们进行类型转换。</p>
<pre><code class="language-c++">void print_vector(const std::vector&lt;int&gt; &amp;v) {
    for (auto item : v)
        std::cout &lt;&lt; item &lt;&lt; &quot;\n&quot;;
}
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; print_vector([1, 2, 3])
1 2 3
</code></pre>
<p>这个例子中，pybind11将创建一个<code>std::vector&lt;int&gt;</code>实例，并从Python list中拷贝每个元素。然后将该实例传递给<code>print_vector</code>。同样的事情发生在另一个方向：新建了一个list，并从C++的vector中获取元素值。</p>
<p>如下表所示，多数转换是开箱即用的。他们相当方便，但请记住一点，这些转换是基于数据拷贝的。这对小型的不变的类型相当友好，对于大型数据结构则相当昂贵。这可以通过自定义包装类型重载自动转换来规避（如上面提到的方法1）。This requires some manual effort and more details are available in the <a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque">Making opaque types</a> section.</p>
<p><strong>内置转换的列表</strong></p>
<p>下面基础数据类型是开箱即用的（有些可能需要include额外的头文件）。</p>
<div class="table-wrapper"><table><thead><tr><th>Data type</th><th>Description</th><th>Header file</th></tr></thead><tbody>
<tr><td><code>int8_t</code>, <code>uint8_t</code></td><td>8-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>int16_t</code>, <code>uint16_t</code></td><td>16-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>int32_t</code>, <code>uint32_t</code></td><td>32-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>int64_t</code>, <code>uint64_t</code></td><td>64-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>ssize_t</code>, <code>size_t</code></td><td>Platform-dependent size</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>float</code>, <code>double</code></td><td>Floating point types</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>bool</code></td><td>Two-state Boolean type</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>char</code></td><td>Character literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>char16_t</code></td><td>UTF-16 character literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>char32_t</code></td><td>UTF-32 character literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>wchar_t</code></td><td>Wide character literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>const char *</code></td><td>UTF-8 string literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>const char16_t *</code></td><td>UTF-16 string literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>const char32_t *</code></td><td>UTF-32 string literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>const wchar_t *</code></td><td>Wide string literal</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::string</code></td><td>STL dynamic UTF-8 string</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::u16string</code></td><td>STL dynamic UTF-16 string</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::u32string</code></td><td>STL dynamic UTF-32 string</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::wstring</code></td><td>STL dynamic wide string</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::string_view</code>, <code>std::u16string_view</code>, etc.</td><td>STL C++17 string views</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::pair&lt;T1, T2&gt;</code></td><td>Pair of two custom types</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::tuple&lt;...&gt;</code></td><td>Arbitrary tuple of types</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::reference_wrapper&lt;...&gt;</code></td><td>Reference type wrapper</td><td><code>pybind11/pybind11.h</code></td></tr>
<tr><td><code>std::complex&lt;T&gt;</code></td><td>Complex numbers</td><td><code>pybind11/complex.h</code></td></tr>
<tr><td><code>std::array&lt;T, Size&gt;</code></td><td>STL static array</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::vector&lt;T&gt;</code></td><td>STL dynamic array</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::deque&lt;T&gt;</code></td><td>STL double-ended queue</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::valarray&lt;T&gt;</code></td><td>STL value array</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::list&lt;T&gt;</code></td><td>STL linked list</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::map&lt;T1, T2&gt;</code></td><td>STL ordered map</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::unordered_map&lt;T1, T2&gt;</code></td><td>STL unordered map</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::set&lt;T&gt;</code></td><td>STL ordered set</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::unordered_set&lt;T&gt;</code></td><td>STL unordered set</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::optional&lt;T&gt;</code></td><td>STL optional type (C++17)</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::experimental::optional&lt;T&gt;</code></td><td>STL optional type (exp.)</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::variant&lt;...&gt;</code></td><td>Type-safe union (C++17)</td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::filesystem::path&lt;T&gt;</code></td><td>STL path (C++17) <a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#id2">1</a></td><td><code>pybind11/stl.h</code></td></tr>
<tr><td><code>std::function&lt;...&gt;</code></td><td>STL polymorphic function</td><td><code>pybind11/functional.h</code></td></tr>
<tr><td><code>std::chrono::duration&lt;...&gt;</code></td><td>STL time duration</td><td><code>pybind11/chrono.h</code></td></tr>
<tr><td><code>std::chrono::time_point&lt;...&gt;</code></td><td>STL date/time</td><td><code>pybind11/chrono.h</code></td></tr>
<tr><td><code>Eigen::Matrix&lt;...&gt;</code></td><td>Eigen: dense matrix</td><td><code>pybind11/eigen.h</code></td></tr>
<tr><td><code>Eigen::Map&lt;...&gt;</code></td><td>Eigen: mapped memory</td><td><code>pybind11/eigen.h</code></td></tr>
<tr><td><code>Eigen::SparseMatrix&lt;...&gt;</code></td><td>Eigen: sparse matrix</td><td><code>pybind11/eigen.h</code></td></tr>
</tbody></table>
</div>
<h3 id="112-strings-bytes-and-unicode-conversions"><a class="header" href="#112-strings-bytes-and-unicode-conversions">11.2 Strings, bytes and Unicode conversions</a></h3>
<blockquote>
<p>Note: 本节讨论的string处理基于Python3 strings。对于python2.7，使用<code>unicode</code>替换<code>str</code>，<code>str</code>替换<code>bytes</code>。Python2.7用于最好使用<code>from __future__ import unicode_literals</code>避免无意间使用<code>str</code>代替<code>unicode</code>。</p>
</blockquote>
<h4 id="1121-传递python-strings到c"><a class="header" href="#1121-传递python-strings到c">11.2.1 传递Python strings到C++</a></h4>
<p>当向一个接收<code>std::string</code>或<code>char *</code>参数的函数传递Python的<code>str</code>时，pybind11会将Python字符串编码为UTF-8。所有的Python <code>str</code>都能够用UTF-8编码，所以这个操作不会失败。</p>
<p>C++语言是encoding agnostic。程序员负责处理编码，最简单的做法就是每处都使用UTF-8。</p>
<pre><code class="language-c++">m.def(&quot;utf8_test&quot;,
    [](const std::string &amp;s) {
        cout &lt;&lt; &quot;utf-8 is icing on the cake.\n&quot;;
        cout &lt;&lt; s;
    }
);
m.def(&quot;utf8_charptr&quot;,
    [](const char *s) {
        cout &lt;&lt; &quot;My favorite food is\n&quot;;
        cout &lt;&lt; s;
    }
);
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; utf8_test(&quot;🎂&quot;)
utf-8 is icing on the cake.
🎂

&gt;&gt;&gt; utf8_charptr(&quot;🍕&quot;)
My favorite food is
🍕
</code></pre>
<blockquote>
<p>Note: 有些终端模拟器不支持UTF-8或emoji字体，上面的例子可能无法显示。</p>
</blockquote>
<p>无论C++函数的参数是传值或引用，是否是const，结果都是一样的。</p>
<p><strong>向C++传递bytes对象</strong></p>
<p>向接收<code>std::string</code>或<code>char *</code>类型参数的C++函数传递Python bytes对象无需转换。在Python3上，如果想要函数只接收bytes，不接收str，可以声明参数类型为<code>py::bytes</code>。</p>
<h4 id="1122-向python返回c-字符串"><a class="header" href="#1122-向python返回c-字符串">11.2.2 向Python返回C++ 字符串</a></h4>
<p>当C++函数返回<code>std::string</code>或<code>char*</code>参数给Python调用者时，pybind11会将字符串以UTF-8格式解码给原生Python str，类似于Python中的<code>bytes.decode('utf-8')</code>。如果隐式转换失败，pybind11将会抛出异常<code>UnicodeDecodeError</code>。</p>
<pre><code class="language-c++">m.def(&quot;std_string_return&quot;,
    []() {
        return std::string(&quot;This string needs to be UTF-8 encoded&quot;);
    }
);
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; isinstance(example.std_string_return(), str)
True
</code></pre>
<p>因为UTF-8包含纯ASCII，返回一个纯ASCII字符串到Python没有任何问题。否则就需要确保编码是有效的UTF-8。</p>
<blockquote>
<p>Warning: 隐式转换假定<code>char *</code>字符串以null为结束符。若不是，将导致缓冲区溢出。</p>
</blockquote>
<p><strong>显式转换</strong></p>
<p>如果C++代码构造了一个非UTF-8的string字符串，可以执行显式转换并返回<code>py::str</code>对象。显式转换与隐式转换的开销相同。</p>
<pre><code class="language-c++">// This uses the Python C API to convert Latin-1 to Unicode
m.def(&quot;str_output&quot;,
    []() {
        std::string s = &quot;Send your r\xe9sum\xe9 to Alice in HR&quot;; // Latin-1
        py::str py_s = PyUnicode_DecodeLatin1(s.data(), s.length());
        return py_s;
    }
);
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; str_output()
'Send your résumé to Alice in HR'
</code></pre>
<p><a href="https://docs.python.org/3/c-api/unicode.html#built-in-codecs">Python C API</a>提供了一些内置的编解码方法可以使用。也可以使用第三方库如libiconv 来转换UTF-8。</p>
<p><strong>不使用类型转换来返回C++字符串</strong></p>
<p>如果C++ <code>std::string</code>中的数据不表示文本，则应该以<code>bytes</code>的形式传递给Python，这时我们可以返回一个<code>py::btyes</code>对象。</p>
<pre><code class="language-c++">m.def(&quot;return_bytes&quot;,
    []() {
        std::string s(&quot;\xba\xd0\xba\xd0&quot;);  // Not valid UTF-8
        return py::bytes(s);  // Return the data without transcoding
    }
);
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; example.return_bytes()
b'\xba\xd0\xba\xd0'
</code></pre>
<p>注意：pybind11可以将bytes无需编码地转换为<code>std::string</code>，但不能不经编码地隐式转换<code>std::string</code>到bytes。</p>
<pre><code class="language-c++">m.def(&quot;asymmetry&quot;,
    [](std::string s) {  // Accepts str or bytes from Python
        return s;  // Looks harmless, but implicitly converts to str
    }
);
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; isinstance(example.asymmetry(b&quot;have some bytes&quot;), str)
True

&gt;&gt;&gt; example.asymmetry(b&quot;\xba\xd0\xba\xd0&quot;)  # invalid utf-8 as bytes
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xba in position 0: invalid start byte
</code></pre>
<h4 id="1123-宽字符串"><a class="header" href="#1123-宽字符串">11.2.3 宽字符串</a></h4>
<p>向入参为<code>std::wstring</code>、<code>wchar_t*</code>、<code>std::u16string</code>或<code>std::u32string</code>的C++函数传递Python str对象，str将被编码为UTF-16或UTF-32（具体哪种取决于C++编译器的支持）。当C++函数返回这些类型的字符串到Python str时，需要保证字符串是合法的UTF-16或UTF-32。</p>
<pre><code class="language-c++">#define UNICODE
#include &lt;windows.h&gt;

m.def(&quot;set_window_text&quot;,
    [](HWND hwnd, std::wstring s) {
        // Call SetWindowText with null-terminated UTF-16 string
        ::SetWindowText(hwnd, s.c_str());
    }
);
m.def(&quot;get_window_text&quot;,
    [](HWND hwnd) {
        const int buffer_size = ::GetWindowTextLength(hwnd) + 1;
        auto buffer = std::make_unique&lt; wchar_t[] &gt;(buffer_size);

        ::GetWindowText(hwnd, buffer.data(), buffer_size);

        std::wstring text(buffer.get());

        // wstring will be converted to Python str
        return text;
    }
);
</code></pre>
<blockquote>
<p>警告：带<code>--enable-unicode=ucs2</code>选项编译的Python 2.7和3.3版本可能不支持上述的宽字符串。</p>
</blockquote>
<p>多字节编码地字符串，如Shift-JIS，必须转换为UTF-8/16/32后，再返回给Python。</p>
<h4 id="1124-字符类型"><a class="header" href="#1124-字符类型">11.2.4 字符类型</a></h4>
<p>向一个入参为字符类型（char, wchar_t）的C++函数，传递Python str，C++函数将接收str的首字符。如果字符串超过一个Unicode字符长度，将忽略尾部字节。</p>
<p>当C++返回一个字符变量时，它将被转化为单字符的str变量。</p>
<pre><code class="language-c++">m.def(&quot;pass_char&quot;, [](char c) { return c; });
m.def(&quot;pass_wchar&quot;, [](wchar_t w) { return w; });
</code></pre>
<pre><code class="language-python">example.pass_char(&quot;A&quot;)
'A'
</code></pre>
<p>虽然C++可以将整数转换为字符类型（<code>char c = 0x65</code>），pybind11并不会隐式转换Python整数到字符类型。可以使用<code>chr()</code>Python函数来将整数转换为字符。</p>
<pre><code class="language-python">&gt;&gt;&gt; example.pass_char(0x65)
TypeError

&gt;&gt;&gt; example.pass_char(chr(0x65))
'A'
</code></pre>
<p>如果需要使用8-bit整数，可使用<code>int8_t</code>或<code>uint8_t</code>作为参数类型。</p>
<h4 id="1125-grapheme-clusters"><a class="header" href="#1125-grapheme-clusters">11.2.5 Grapheme clusters</a></h4>
<p>A single grapheme may be represented by two or more Unicode characters. For example ‘é’ is usually represented as U+00E9 but can also be expressed as the combining character sequence U+0065 U+0301 (that is, the letter ‘e’ followed by a combining acute accent). The combining character will be lost if the two-character sequence is passed as an argument, even though it renders as a single grapheme.</p>
<pre><code>&gt;&gt;&gt; example.pass_wchar(&quot;é&quot;)
'é'

&gt;&gt;&gt; combining_e_acute = &quot;e&quot; + &quot;\u0301&quot;

&gt;&gt;&gt; combining_e_acute
'é'

&gt;&gt;&gt; combining_e_acute == &quot;é&quot;
False

&gt;&gt;&gt; example.pass_wchar(combining_e_acute)
'e'
</code></pre>
<p>Normalizing combining characters before passing the character literal to C++ may resolve <em>some</em> of these issues:</p>
<pre><code>&gt;&gt;&gt; example.pass_wchar(unicodedata.normalize(&quot;NFC&quot;, combining_e_acute))
'é'
</code></pre>
<p>In some languages (Thai for example), there are <a href="http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">graphemes that cannot be expressed as a single Unicode code point</a>, so there is no way to capture them in a C++ character type.</p>
<h4 id="1126-c17-string_view"><a class="header" href="#1126-c17-string_view">11.2.6 c++17 string_view</a></h4>
<p>C++17 string views are automatically supported when compiling in C++17 mode. They follow the same rules for encoding and decoding as the corresponding STL string type (for example, a <code>std::u16string_view</code> argument will be passed UTF-16-encoded data, and a returned <code>std::string_view</code> will be decoded as UTF-8).</p>
<h3 id="113-stl容器"><a class="header" href="#113-stl容器">11.3 STL容器</a></h3>
<h4 id="1131-自动转换"><a class="header" href="#1131-自动转换">11.3.1 自动转换</a></h4>
<p>包含头文件<code>pybind11/stl.h</code>后，自动支持 <code>std::vector&lt;&gt;</code>/<code>std::deque&lt;&gt;</code>/<code>std::list&lt;&gt;</code>/<code>std::array&lt;&gt;</code>/<code>std::valarray&lt;&gt;</code>, <code>std::set&lt;&gt;</code>/<code>std::unordered_set&lt;&gt;</code>, 和<code>std::map&lt;&gt;</code>/<code>std::unordered_map&lt;&gt;</code> 到Python <code>list</code>, <code>set</code> 和 <code>dict</code> 的类型转换。 <code>std::pair&lt;&gt;</code> 和<code>std::tuple&lt;&gt;</code> 类型转换在<code>pybind11/pybind11.h</code>中已经支持。</p>
<p>隐式转换的主要缺点就是Python和C++之间的容器类型转换都需要拷贝数据，这对程序语义和性能有一定的影响。后续章节将介绍如何避免该问题。</p>
<blockquote>
<p>Note: 这些类型任意嵌套都是可以的。</p>
</blockquote>
<h4 id="1132-c17库的容器"><a class="header" href="#1132-c17库的容器">11.3.2 C++17库的容器</a></h4>
<p><code>pybind11/stl.h</code>支持C++17的 <code>std::optional&lt;&gt;</code> 和<code>std::variant&lt;&gt;</code>，C++14的<code>std::experimental::optional&lt;&gt;</code>。</p>
<p>C++11中也存在这些容器的其他版本，如Boost中。pybind11提供了一个简单的方法<code>type_caster</code>来处理这些类型：</p>
<pre><code class="language-c++">// `boost::optional` as an example -- can be any `std::optional`-like container
namespace pybind11 { namespace detail {
    template &lt;typename T&gt;
    struct type_caster&lt;boost::optional&lt;T&gt;&gt; : optional_caster&lt;boost::optional&lt;T&gt;&gt; {};
}}
</code></pre>
<p>上述内容应放到头文件中，并在需要的地方包含它们。Similarly, a specialization can be provided for custom variant types:</p>
<pre><code class="language-c++">// `boost::variant` as an example -- can be any `std::variant`-like container
namespace pybind11 { namespace detail {
    template &lt;typename... Ts&gt;
    struct type_caster&lt;boost::variant&lt;Ts...&gt;&gt; : variant_caster&lt;boost::variant&lt;Ts...&gt;&gt; {};

    // Specifies the function used to visit the variant -- `apply_visitor` instead of `visit`
    template &lt;&gt;
    struct visit_helper&lt;boost::variant&gt; {
        template &lt;typename... Args&gt;
        static auto call(Args &amp;&amp;...args) -&gt; decltype(boost::apply_visitor(args...)) {
            return boost::apply_visitor(args...);
        }
    };
}} // namespace pybind11::detail
</code></pre>
<p>The <code>visit_helper</code> specialization is not required if your <code>name::variant</code> provides a <code>name::visit()</code> function. For any other function name, the specialization must be included to tell pybind11 how to visit the variant.</p>
<blockquote>
<p>Warning: When converting a <code>variant</code> type, pybind11 follows the same rules as when determining which function overload to call (<a href="https://pybind11.readthedocs.io/en/stable/advanced/functions.html#overload-resolution">Overload resolution order</a>), and so the same caveats hold. In particular, the order in which the <code>variant</code>’s alternatives are listed is important, since pybind11 will try conversions in this order. This means that, for example, when converting <code>variant&lt;int, bool&gt;</code>, the <code>bool</code> variant will never be selected, as any Python <code>bool</code> is already an <code>int</code> and is convertible to a C++ <code>int</code>. Changing the order of alternatives (and using <code>variant&lt;bool, int&gt;</code>, in this example) provides a solution.</p>
</blockquote>
<h4 id="1133-制作opaque类型"><a class="header" href="#1133-制作opaque类型">11.3.3 制作opaque类型</a></h4>
<p>pybind11严重依赖于模板匹配机制来转换STL类型的参数和返回值，如vector，链表，哈希表等。甚至会递归处理，如lists of hash maps of pairs of elementary and custom types。</p>
<p>然而，这个方法的一个基本限制就是，Python和C++类型的转换涉及到拷贝操作，这妨碍了pass-by-reference的语义。</p>
<p>假设我们绑定如下函数：</p>
<pre><code class="language-c++">void append_1(std::vector&lt;int&gt; &amp;v) {
   v.push_back(1);
}
</code></pre>
<p>在Python中调用它：</p>
<pre><code class="language-python">&gt;&gt;&gt; v = [5, 6]
&gt;&gt;&gt; append_1(v)
&gt;&gt;&gt; print(v)
[5, 6]
</code></pre>
<p>如你所见，通过引用传递STL数据时，修改并不会传递到Python侧。相同的场景表现在通过<code>def_readwrite</code>或<code>def_readonly</code>函数公开STL数据结构时：</p>
<pre><code class="language-c++">/* ... definition ... */

class MyClass {
    std::vector&lt;int&gt; contents;
};

/* ... binding code ... */

py::class_&lt;MyClass&gt;(m, &quot;MyClass&quot;)
    .def(py::init&lt;&gt;())
    .def_readwrite(&quot;contents&quot;, &amp;MyClass::contents);
</code></pre>
<p>这个例子中，属性可以整体的读写。但是，涉及到append操作时就无能为力了：</p>
<pre><code class="language-python">&gt;&gt;&gt; m = MyClass()
&gt;&gt;&gt; m.contents = [5, 6]
&gt;&gt;&gt; print(m.contents)
[5, 6]
&gt;&gt;&gt; m.contents.append(7)
&gt;&gt;&gt; print(m.contents)
[5, 6]
</code></pre>
<p>最后，在处理大型列表时，涉及的拷贝操作会耗费巨大。为处理上述场景，pybind11提供了<code>PYBIND11_MAKE_OPAQUE(T)</code>来禁用基于模板的类型转换机制，从而使他们变得不透明（<em>opaque</em>）。opaque对象的内容永远不会被检查或提取，因此它们可以通过引用传递。例如，要将<code>std::vector&lt;int&gt;</code>转换为opaque类型，需要在所有绑定代码之前添加声明：</p>
<pre><code class="language-c++">PYBIND11_MAKE_OPAQUE(std::vector&lt;int&gt;);
</code></pre>
<p>这个宏必须在顶层（所有命名空间外）设定，因为然添加了<code>type_caster</code>的模板实例化。如果你绑定代码包含多个编译单元，需要在每个文件使用<code>std::vector&lt;int&gt;</code>前指定（通常通过公共的头文件来实现）。opaque对象有相关的<code>class_</code>定义来联系Python中的类名，还需定义一组有用的操作，如：</p>
<pre><code class="language-c++">py::class_&lt;std::vector&lt;int&gt;&gt;(m, &quot;IntVector&quot;)
    .def(py::init&lt;&gt;())
    .def(&quot;clear&quot;, &amp;std::vector&lt;int&gt;::clear)
    .def(&quot;pop_back&quot;, &amp;std::vector&lt;int&gt;::pop_back)
    .def(&quot;__len__&quot;, [](const std::vector&lt;int&gt; &amp;v) { return v.size(); })
    .def(&quot;__iter__&quot;, [](std::vector&lt;int&gt; &amp;v) {
       return py::make_iterator(v.begin(), v.end());
    }, py::keep_alive&lt;0, 1&gt;()) /* Keep vector alive while iterator is used */
    // ....
</code></pre>
<h4 id="1134-绑定stl容器"><a class="header" href="#1134-绑定stl容器">11.3.4 绑定STL容器</a></h4>
<p>公开STL容器作为一个Python对象时一个相当常见的需求，因此pybind11也提供了一个可选的头文件<code>pybind11/stl_bind.h</code>来做这件事。映射容器会尽可能的去匹配Python对应类型的行为。下面示例将展示该机制的使用方法：</p>
<pre><code class="language-c++">// Don't forget this
#include &lt;pybind11/stl_bind.h&gt;

PYBIND11_MAKE_OPAQUE(std::vector&lt;int&gt;);
PYBIND11_MAKE_OPAQUE(std::map&lt;std::string, double&gt;);

// ...

// later in binding code:
py::bind_vector&lt;std::vector&lt;int&gt;&gt;(m, &quot;VectorInt&quot;);
py::bind_map&lt;std::map&lt;std::string, double&gt;&gt;(m, &quot;MapStringDouble&quot;);
</code></pre>
<p>绑定STL容器时，pybind11会根据容器元素的类型来决定该容器是否应该局限于模块内（参考Module-local class bindings特性）。如果容器元素的类型不是已经绑定的自定义类型且未标识<code>py::module_local</code>，那么容器绑定将应用<code>py::module_local</code>。这包括数值类型、strings、Eigen类型，和其他在绑定STL容器时还未绑定的类型。module-local绑定的意图是为了避免模块间的潜在的冲突（如，两个独立的模块都试图绑定<code>std::vector&lt;int&gt;</code>）。</p>
<p>通过指定属性<code>py::module_local()</code>或<code>py_module_local(false)</code>，你也可以强制绑定的STL容器公开在模块内或全局：</p>
<pre><code class="language-c++">py::bind_vector&lt;std::vector&lt;int&gt;&gt;(m, &quot;VectorInt&quot;, py::module_local(false));
</code></pre>
<p>注意：这样的全局绑定可能会导致模块无法加载，如果其他的模块也绑定了相同的容器类型（如<code>std::vector&lt;int&gt;</code>）并以加载。</p>
<h3 id="114-函数对象"><a class="header" href="#114-函数对象">11.4 函数对象</a></h3>
<p>要使能以下属性，需要包含<code>pybind11/functional.h</code>。</p>
<p><strong>回调并传递匿名函数</strong></p>
<p>C++11标准引入了功能强大的lambda函数和泛函对象<code>std::function&lt;&gt;</code>。lambda函数有两种类型：无状态lambda函数类似于指向一块匿名代码的函数指针，而有状态lambda函数还依赖于存储在lambda闭包对象中的被捕获的参数。</p>
<p>这里有一个接收任意函数签名为<code>int -&gt; int</code>的函数类型参数（有状态或无状态）：</p>
<pre><code class="language-c++">int func_arg(const std::function&lt;int(int)&gt; &amp;f) {
    return f(10);
}
</code></pre>
<p>下面的例子更复杂，它的入参是一个函数对象，并返回一个同样类型的函数对象。返回值是一个有状态的lambda函数，它捕获了<code>f</code>参数：</p>
<pre><code class="language-c++">std::function&lt;int(int)&gt; func_ret(const std::function&lt;int(int)&gt; &amp;f) {
    return [f](int i) {
        return f(i) + 1;
    };
}
</code></pre>
<p>在C++回调函数中使用python具名参数，需要使用<code>py::cpp_function</code>包裹，类似于下面的代码：</p>
<pre><code class="language-c++">py::cpp_function func_cpp() {
    return py::cpp_function([](int i) { return i+1; },
       py::arg(&quot;number&quot;));
}
</code></pre>
<p>包含<code>pybind11/functional.h</code>头文件后，可以简单地直接为上述函数生成绑定代码：</p>
<pre><code class="language-c++">#include &lt;pybind11/functional.h&gt;

PYBIND11_MODULE(example, m) {
    m.def(&quot;func_arg&quot;, &amp;func_arg);
    m.def(&quot;func_ret&quot;, &amp;func_ret);
    m.def(&quot;func_cpp&quot;, &amp;func_cpp);
}
</code></pre>
<p>Python中交互示例如下：</p>
<pre><code class="language-python">$ python
&gt;&gt;&gt; import example
&gt;&gt;&gt; def square(i):
...     return i * i
...
&gt;&gt;&gt; example.func_arg(square)
100L
&gt;&gt;&gt; square_plus_1 = example.func_ret(square)
&gt;&gt;&gt; square_plus_1(4)
17L
&gt;&gt;&gt; plus_1 = func_cpp()
&gt;&gt;&gt; plus_1(number=43)
44L
</code></pre>
<blockquote>
<p>Warning</p>
<p>请记住在从C++传递函数对象到Python的过程中（反向亦然），将生成一些包装代码来两种语言的函数调用。这种翻译自然会稍微增加函数调用的开销。当一个函数在Python和C++之间来回拷贝多次时，包装层数会不断累积，会明显降低性能。</p>
<p>这里有个例外：一个无状态函数作为参数传递给在Python中公开的另一个C++函数时，将不会有额外的开销。Pybind11将从封装的函数中提取C++函数指针，以回避潜在地C++ -&gt; Python -&gt; C++的往返。</p>
</blockquote>
<h3 id="115-chrono"><a class="header" href="#115-chrono">11.5 Chrono</a></h3>
<p>包含<code>pybind11/chrono</code>将使能C++11 chrono和Python datatime对象将的自动转换，还支持python floats（从<code>time.monotonic()</code>或<code>time.perf_counter()</code>获取的）和<code>time.process_time()</code>到durations的转换。</p>
<h4 id="1151-c11时钟的概览"><a class="header" href="#1151-c11时钟的概览">11.5.1 C++11时钟的概览</a></h4>
<p>使用这些转换时容易混淆的点是，C++11中提供的各种时钟的差异。C++11标准定义了三种时钟类型，用户也可以根据自身需求定义自己的时钟类型。这些时钟有着不用的属性，与Python之间转换时也会获得不同的结果。</p>
<p>标准定义的第一种时钟<code>std::chrono::system_clock</code>。它测量当前的时间和日期。但是，这个时钟会随着操作系统的时钟变化而改变。例如，在系统时间与时间服务器同步时，这个时钟也会跟着改变。这对计时功能来说很糟糕，但对测量wall time还是有用的。</p>
<p>标准定义的第二种时钟<code>std::chrono::steady_clock</code>。这个时钟以稳定的速度跳动，从不调整。这非常实用于计时功能，但与实际时间和日志并不一致。这个时间通常是你操作系统已经运行的时间，虽然不是必须的。这个时钟永远不会与系统时钟相同，因为系统时钟可以改变，但steady_clock不能。</p>
<p>标准定义的第二种时钟<code>std::chrono::high_resolution_clock</code>。它是系统中分辨率最高的时钟，通常是system clock 或 steady clock的一种，也可以有自己独立的时钟。需要注意的是，你在Python中获取到的该时钟的转换值，可能存在差异，这取决于系统的实现。如果它是系统时钟的一种，Python将得到datetime对象，否则将得到timedelta对象。</p>
<h4 id="1152-提供的转换"><a class="header" href="#1152-提供的转换">11.5.2 提供的转换</a></h4>
<p><strong>C++到Python</strong></p>
<ul>
<li><code>std::chrono::system_clock::time_point</code> → <code>datetime.datetime</code></li>
<li><code>std::chrono::duration</code> → <code>datetime.timedelta</code></li>
<li><code>std::chrono::[other_clocks]::time_point</code> → <code>datetime.timedelta</code></li>
</ul>
<p><strong>Python到C++</strong></p>
<ul>
<li><code>datetime.datetime</code>or<code>datetime.date</code>or<code>datetime.time</code> → <code>std::chrono::system_clock::time_point</code></li>
<li><code>datetime.timedelta</code> → <code>std::chrono::duration</code></li>
<li><code>datetime.timedelta</code> → <code>std::chrono::[other_clocks]::time_point</code></li>
<li><code>float</code> → <code>std::chrono::duration</code></li>
<li><code>float</code> → <code>std::chrono::[other_clocks]::time_point</code></li>
</ul>
<h3 id="116-eigen"><a class="header" href="#116-eigen">11.6 Eigen</a></h3>
<p>没接触过Eigen，先不翻译。</p>
<h3 id="117-自定义类型转换"><a class="header" href="#117-自定义类型转换">11.7 自定义类型转换</a></h3>
<p>在极少数情况下，程序可能需要一些pybind11没有提供的自定义类型转换，这需要使用到原始的Python C API。这是相当高级的使用方法，只有熟悉Python引用计数复杂之处的专家才能使用。</p>
<p>The following snippets demonstrate how this works for a very simple <code>inty</code> type that that should be convertible from Python types that provide a <code>__int__(self)</code> method.</p>
<pre><code class="language-c++">struct inty { long long_value; };

void print(inty s) {
    std::cout &lt;&lt; s.long_value &lt;&lt; std::endl;
}
</code></pre>
<p>The following Python snippet demonstrates the intended usage from the Python side:</p>
<pre><code class="language-python">class A:
    def __int__(self):
        return 123


from example import print

print(A())
</code></pre>
<p>To register the necessary conversion routines, it is necessary to add an instantiation of the <code>pybind11::detail::type_caster&lt;T&gt;</code> template. Although this is an implementation detail, adding an instantiation of this type is explicitly allowed.</p>
<pre><code class="language-c++">namespace pybind11 { namespace detail {
    template &lt;&gt; struct type_caster&lt;inty&gt; {
    public:
        /**
         * This macro establishes the name 'inty' in
         * function signatures and declares a local variable
         * 'value' of type inty
         */
        PYBIND11_TYPE_CASTER(inty, _(&quot;inty&quot;));

        /**
         * Conversion part 1 (Python-&gt;C++): convert a PyObject into a inty
         * instance or return false upon failure. The second argument
         * indicates whether implicit conversions should be applied.
         */
        bool load(handle src, bool) {
            /* Extract PyObject from handle */
            PyObject *source = src.ptr();
            /* Try converting into a Python integer value */
            PyObject *tmp = PyNumber_Long(source);
            if (!tmp)
                return false;
            /* Now try to convert into a C++ int */
            value.long_value = PyLong_AsLong(tmp);
            Py_DECREF(tmp);
            /* Ensure return code was OK (to avoid out-of-range errors etc) */
            return !(value.long_value == -1 &amp;&amp; !PyErr_Occurred());
        }

        /**
         * Conversion part 2 (C++ -&gt; Python): convert an inty instance into
         * a Python object. The second and third arguments are used to
         * indicate the return value policy and parent object (for
         * ``return_value_policy::reference_internal``) and are generally
         * ignored by implicit casters.
         */
        static handle cast(inty src, return_value_policy /* policy */, handle /* parent */) {
            return PyLong_FromLong(src.long_value);
        }
    };
}} // namespace pybind11::detail
</code></pre>
<blockquote>
<p>Note: A <code>type_caster&lt;T&gt;</code> defined with <code>PYBIND11_TYPE_CASTER(T, ...)</code> requires that <code>T</code> is default-constructible (<code>value</code> is first default constructed and then <code>load()</code> assigns to it).</p>
</blockquote>
<blockquote>
<p>Warning: When using custom type casters, it’s important to declare them consistently in every compilation unit of the Python extension module. Otherwise, undefined behavior can ensue.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="12-python-c接口"><a class="header" href="#12-python-c接口">12. Python C++接口</a></h2>
<p>pybind11通过简单的C++包装公开了Python类型和函数，这使得我们可以方便的在C++中调用Python代码，而无需借助Python C API。</p>
<h3 id="121-python类型"><a class="header" href="#121-python类型">12.1 Python类型</a></h3>
<h4 id="1211-可用的封装"><a class="header" href="#1211-可用的封装">12.1.1 可用的封装</a></h4>
<p>所有主要的Python类型通过简单C++类封装公开出来了，可以当做参数参数来使用。包括： <code>handle</code>, <code>object</code>, <code>bool_</code>, <code>int_</code>, <code>float_</code>, <code>str</code>, <code>bytes</code>, <code>tuple</code>, <code>list</code>, <code>dict</code>, <code>slice</code>, <code>none</code>, <code>capsule</code>, <code>iterable</code>, <code>iterator</code>, <code>function</code>, <code>buffer</code>, <code>array</code>, 和<code>array_t</code>.</p>
<blockquote>
<p>Warning: Be sure to review the <a href="https://pybind11.readthedocs.io/en/stable/advanced/pycpp/object.html#pytypes-gotchas">Gotchas</a> before using this heavily in your C++ API.</p>
</blockquote>
<h4 id="1212-在c中实例化复合python类型"><a class="header" href="#1212-在c中实例化复合python类型">12.1.2 在C++中实例化复合Python类型</a></h4>
<p>字典对象可以通过<code>dict</code>构造函数来初始化：</p>
<pre><code class="language-c++">using namespace pybind11::literals; // to bring in the `_a` literal
py::dict d(&quot;spam&quot;_a=py::none(), &quot;eggs&quot;_a=42);
</code></pre>
<p>tuple对象可以通过<code>py::make_tuple()</code>来构造：</p>
<pre><code class="language-c++">py::tuple tup = py::make_tuple(42, py::none(), &quot;spam&quot;);
</code></pre>
<p>每个元素都会被转换为支持的Python类型，</p>
<p>simple namespace可以这样实例化：</p>
<pre><code class="language-c++">using namespace pybind11::literals;  // to bring in the `_a` literal
py::object SimpleNamespace = py::module_::import(&quot;types&quot;).attr(&quot;SimpleNamespace&quot;);
py::object ns = SimpleNamespace(&quot;spam&quot;_a=py::none(), &quot;eggs&quot;_a=42);
</code></pre>
<p>namespace的属性可以通过<code>py::delattr()</code>，<code>py::getattr()</code>和<code>py::setattr()</code>来修改。Simple namespaces可以作为类实例的轻量级替代。</p>
<h4 id="1213-相互转换"><a class="header" href="#1213-相互转换">12.1.3 相互转换</a></h4>
<p>混合编程时，通常需要将任意C++类型转换为Python类型，可以使用<code>py::cast()</code>来实现：</p>
<pre><code class="language-c++">MyClass *cls = ...;
py::object obj = py::cast(cls);
</code></pre>
<p>反方向可以使用以下语法：</p>
<pre><code class="language-c++">py::object obj = ...;
MyClass *cls = obj.cast&lt;MyClass *&gt;();
</code></pre>
<p>转换失败时，两个方向都会抛出<code>cast_error</code>异常。</p>
<h4 id="1214-在c中访问python库"><a class="header" href="#1214-在c中访问python库">12.1.4 在C++中访问Python库</a></h4>
<p>在C++中也可以导入Python标准库或Python环境（sys.path)可找到的库的对象。示例如下：</p>
<pre><code class="language-c++">// Equivalent to &quot;from decimal import Decimal&quot;
py::object Decimal = py::module_::import(&quot;decimal&quot;).attr(&quot;Decimal&quot;);

// Try to import scipy
py::object scipy = py::module_::import(&quot;scipy&quot;);
return scipy.attr(&quot;__version__&quot;);
</code></pre>
<h4 id="1215-调用python函数"><a class="header" href="#1215-调用python函数">12.1.5 调用Python函数</a></h4>
<p>通过<code>operator()</code>可以调用Python类、函数和方法。</p>
<pre><code class="language-c++">// Construct a Python object of class Decimal
py::object pi = Decimal(&quot;3.14159&quot;);

// Use Python to make our directories
py::object os = py::module_::import(&quot;os&quot;);
py::object makedirs = os.attr(&quot;makedirs&quot;);
makedirs(&quot;/tmp/path/to/somewhere&quot;);
</code></pre>
<p>One can convert the result obtained from Python to a pure C++ version if a <code>py::class_</code> or type conversion is defined.</p>
<pre><code class="language-c++">py::function f = &lt;...&gt;;
py::object result_py = f(1234, &quot;hello&quot;, some_instance);
MyClass &amp;result = result_py.cast&lt;MyClass&gt;();
</code></pre>
<h4 id="1216-调用python对象的方法"><a class="header" href="#1216-调用python对象的方法">12.1.6 调用Python对象的方法</a></h4>
<p>使用<code>.attr</code>可以调用对象的Python方法。</p>
<pre><code class="language-c++">// Calculate e^π in decimal
py::object exp_pi = pi.attr(&quot;exp&quot;)();
py::print(py::str(exp_pi));
</code></pre>
<p>In the example above <code>pi.attr(&quot;exp&quot;)</code> is a <em>bound method</em>: it will always call the method for that same instance of the class. Alternately one can create an <em>unbound method</em> via the Python class (instead of instance) and pass the <code>self</code> object explicitly, followed by other arguments.</p>
<pre><code class="language-c++">py::object decimal_exp = Decimal.attr(&quot;exp&quot;);

// Compute the e^n for n=0..4
for (int n = 0; n &lt; 5; n++) {
    py::print(decimal_exp(Decimal(n));
}
</code></pre>
<h4 id="1217-关键字参数"><a class="header" href="#1217-关键字参数">12.1.7 关键字参数</a></h4>
<p>支持关键字参数，Python语法示例如下：</p>
<pre><code class="language-python">def f(number, say, to):
    ...  # function code


f(1234, say=&quot;hello&quot;, to=some_instance)  # keyword call in Python
</code></pre>
<p>C++中则可以这样写：</p>
<pre><code class="language-c++">using namespace pybind11::literals; // to bring in the `_a` literal
f(1234, &quot;say&quot;_a=&quot;hello&quot;, &quot;to&quot;_a=some_instance); // keyword call in C++
</code></pre>
<h4 id="1218-拆包参数"><a class="header" href="#1218-拆包参数">12.1.8 拆包参数</a></h4>
<p>拆包参数<code>*args</code>和<code>**kwargs</code>可以与其他参数混合使用：</p>
<pre><code class="language-c++">// * unpacking
py::tuple args = py::make_tuple(1234, &quot;hello&quot;, some_instance);
f(*args);

// ** unpacking
py::dict kwargs = py::dict(&quot;number&quot;_a=1234, &quot;say&quot;_a=&quot;hello&quot;, &quot;to&quot;_a=some_instance);
f(**kwargs);

// mixed keywords, * and ** unpacking
py::tuple args = py::make_tuple(1234);
py::dict kwargs = py::dict(&quot;to&quot;_a=some_instance);
f(*args, &quot;say&quot;_a=&quot;hello&quot;, **kwargs);
</code></pre>
<p>Generalized unpacking according to <a href="https://www.python.org/dev/peps/pep-0448/">PEP448</a> is also supported:</p>
<pre><code>py::dict kwargs1 = py::dict(&quot;number&quot;_a=1234);
py::dict kwargs2 = py::dict(&quot;to&quot;_a=some_instance);
f(**kwargs1, &quot;say&quot;_a=&quot;hello&quot;, **kwargs2);
</code></pre>
<h4 id="1219-隐式转换"><a class="header" href="#1219-隐式转换">12.1.9 隐式转换</a></h4>
<p>当使用涉及Python类型的C++接口，或调用Python函数，返回<code>object</code>类型的对象时，会涉及到子类（如dict）的隐式转换。通过<code>operator[]</code>或<code>obj.attr()</code>返回代理对象也是如此。转型到子类可以提供代码的可读性，并允许向需要特定子类类型而不是通用<code>object</code>类型的C++函数传值。</p>
<pre><code class="language-c++">#include &lt;pybind11/numpy.h&gt;
using namespace pybind11::literals;

py::module_ os = py::module_::import(&quot;os&quot;);
py::module_ path = py::module_::import(&quot;os.path&quot;);  // like 'import os.path as path'
py::module_ np = py::module_::import(&quot;numpy&quot;);  // like 'import numpy as np'

py::str curdir_abs = path.attr(&quot;abspath&quot;)(path.attr(&quot;curdir&quot;));
py::print(py::str(&quot;Current directory: &quot;) + curdir_abs);
py::dict environ = os.attr(&quot;environ&quot;);
py::print(environ[&quot;HOME&quot;]);
py::array_t&lt;float&gt; arr = np.attr(&quot;ones&quot;)(3, &quot;dtype&quot;_a=&quot;float32&quot;);
py::print(py::repr(arr + py::int_(1)));
</code></pre>
<p>对<code>object</code>子类的隐式转型，不需要向自定义类那样显式调用<code>obj.cast()</code>。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>If a trivial conversion via move constructor is not possible, both implicit and explicit casting (calling <code>obj.cast()</code>) will attempt a “rich” conversion. For instance, <code>py::list env = os.attr(&quot;environ&quot;);</code> will succeed and is equivalent to the Python code <code>env = list(os.environ)</code> that produces a list of the dict keys.</p>
</blockquote>
<h4 id="12110-处理异常"><a class="header" href="#12110-处理异常">12.1.10 处理异常</a></h4>
<p>Python异常将会包装为<code>py::error_already_set</code>后抛出。详见前面的章节“在C++中处理Python异常”。</p>
<h4 id="12111-gotchas"><a class="header" href="#12111-gotchas">12.1.11 Gotchas</a></h4>
<p><strong>Default-Constructed Wrappers</strong></p>
<p>通过包装类型的默认构造函数，不能得到有效的Python对象（不是<code>py::none</code>），和<code>PyObject*</code>空指针一样。可以通过<code>static_cast&lt;bool&gt;(my_wrapper)</code>来检查。</p>
<p><strong>Assigning py::none() to wrappers</strong></p>
<p>你可能想在C++函数中使用类似<code>py::str</code>和<code>py::dict</code>类型的参数，并给它们<code>py::none</code>默认值。但是，最好的情况是它会因为<code>None</code>无法转型为该类型而失败；最坏的情况是它会默默工作但会破坏你想要的类型（如Python中<code>py::str(py::none)</code>会返回None）。</p>
<h3 id="122-numpy"><a class="header" href="#122-numpy">12.2 NumPy</a></h3>
<h4 id="1221-缓冲协议buffer-protocol"><a class="header" href="#1221-缓冲协议buffer-protocol">12.2.1 缓冲协议（buffer protocol）</a></h4>
<p>Python支持插件库间以一种极其通用且便利方式进行数据交换。类型可以公开缓冲区视图，以提供对内部原始数据进行快速直接访问。假设我们想绑定下面的简单的Matrix类：</p>
<pre><code class="language-c++">class Matrix {
public:
    Matrix(size_t rows, size_t cols) : m_rows(rows), m_cols(cols) {
        m_data = new float[rows*cols];
    }
    float *data() { return m_data; }
    size_t rows() const { return m_rows; }
    size_t cols() const { return m_cols; }
private:
    size_t m_rows, m_cols;
    float *m_data;
};
</code></pre>
<p>下面的绑定代码将Matrix作为一个buffer对象公开，使得Matrices可以转型为NumPy arrays。甚至可以完全避免拷贝操作，类似python语句<code>np.array(matrix_instance, copy = False)</code>。</p>
<pre><code class="language-c++">py::class_&lt;Matrix&gt;(m, &quot;Matrix&quot;, py::buffer_protocol())
   .def_buffer([](Matrix &amp;m) -&gt; py::buffer_info {
        return py::buffer_info(
            m.data(),                               /* Pointer to buffer */
            sizeof(float),                          /* Size of one scalar */
            py::format_descriptor&lt;float&gt;::format(), /* Python struct-style format descriptor */
            2,                                      /* Number of dimensions */
            { m.rows(), m.cols() },                 /* Buffer dimensions */
            { sizeof(float) * m.cols(),             /* Strides (in bytes) for each index */
              sizeof(float) }
        );
    });
</code></pre>
<p>要使新类型支持缓冲协议，需要在<code>py:class_</code>构造函数中指定<code>py::buffer_protocol()</code>的标识，并调用<code>def_buffer()</code>方法定义一个通过给定的matrix实例创建<code>py::buffer_info</code>描述对象。<code>py::buffer_info</code>的内容反映了Python缓冲协议的规范。</p>
<pre><code class="language-c++">struct buffer_info {
    void *ptr;
    py::ssize_t itemsize;
    std::string format;
    py::ssize_t ndim;
    std::vector&lt;py::ssize_t&gt; shape;
    std::vector&lt;py::ssize_t&gt; strides;
};
</code></pre>
<p>要想创建一个支持Python buffer对象为参数的C++函数，可以简单实用<code>py::buffer</code>作为函数参数之一。buffer对象会存在多种配置，因此通常在需要在函数体中进行安全检查。下面的例子，将展示如果定义一个双精度类型的Eigen矩阵的自定义构造函数，支持从兼容buffer对象来初始化（如NumPy matrix）。</p>
<pre><code class="language-c++">/* Bind MatrixXd (or some other Eigen type) to Python */
typedef Eigen::MatrixXd Matrix;

typedef Matrix::Scalar Scalar;
constexpr bool rowMajor = Matrix::Flags &amp; Eigen::RowMajorBit;

py::class_&lt;Matrix&gt;(m, &quot;Matrix&quot;, py::buffer_protocol())
    .def(py::init([](py::buffer b) {
        typedef Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt; Strides;

        /* Request a buffer descriptor from Python */
        py::buffer_info info = b.request();

        /* Some sanity checks ... */
        if (info.format != py::format_descriptor&lt;Scalar&gt;::format())
            throw std::runtime_error(&quot;Incompatible format: expected a double array!&quot;);

        if (info.ndim != 2)
            throw std::runtime_error(&quot;Incompatible buffer dimension!&quot;);

        auto strides = Strides(
            info.strides[rowMajor ? 0 : 1] / (py::ssize_t)sizeof(Scalar),
            info.strides[rowMajor ? 1 : 0] / (py::ssize_t)sizeof(Scalar));

        auto map = Eigen::Map&lt;Matrix, 0, Strides&gt;(
            static_cast&lt;Scalar *&gt;(info.ptr), info.shape[0], info.shape[1], strides);

        return Matrix(map);
    }));
</code></pre>
<p>作为参考，Eigen数据类型的<code>def_buffer()</code>方法类似于如下结构：</p>
<pre><code class="language-c++">.def_buffer([](Matrix &amp;m) -&gt; py::buffer_info {
    return py::buffer_info(
        m.data(),                                /* Pointer to buffer */
        sizeof(Scalar),                          /* Size of one scalar */
        py::format_descriptor&lt;Scalar&gt;::format(), /* Python struct-style format descriptor */
        2,                                       /* Number of dimensions */
        { m.rows(), m.cols() },                  /* Buffer dimensions */
        { sizeof(Scalar) * (rowMajor ? m.cols() : 1),
          sizeof(Scalar) * (rowMajor ? 1 : m.rows()) }
                                                 /* Strides (in bytes) for each index */
    );
 })
</code></pre>
<p>关于绑定Eigen类型更简单的方法(尽管有一些限制)，请参阅Eigen部分。</p>
<h4 id="1222-arrays"><a class="header" href="#1222-arrays">12.2.2 Arrays</a></h4>
<p>将上述代码中的<code>py::buffer</code>替换为<code>py::array</code>，我们可以限制函数只接收NumPy array（而不是任意满足缓冲协议的Python类型）。</p>
<p>在很多场合，我们希望函数只接受特定数据类型的NumPy array，可以使用<code>py::array_t&lt;T&gt;</code>来实现。如下所示，函数需要一个双精度浮点类型的NumPy array。</p>
<pre><code class="language-c++">void f(py::array_t&lt;double&gt; array);
</code></pre>
<p>当上面的函数被其他类型（如int）调用时，绑定代码将试图将输入转型为期望类型的NumPy array。该特性需要包含<code>pybind11/numpy.h</code>头文件。该文件不依赖与NumPy的头文件，因此可以独立于NumPy编译。运行时需要NumPy版本大于1.7.0。</p>
<p>NumPy array的数据并不保证密集排布；此外，数据条目可以以任意的行列跨度分隔。有时，我们需要函数仅接受C（行优先）或Fortran（列优先）次序的密集排布数组。这就需要指定第二个模板参数为<code>py::array::c_style</code>或<code>py::array::f_style</code>。</p>
<pre><code class="language-c++">void f(py::array_t&lt;double, py::array::c_style | py::array::forcecast&gt; array);
</code></pre>
<p><code>py::array::forcecast</code>参数为第二个模板参数的默认值。它确保将不支持的参数转型为满足指定需要的数组，而不是试图匹配下一个函数重载。</p>
<p>arrays有一些基于NumPy API的方法：</p>
<ul>
<li><code>.dtype()</code>返回数组元素的类型。</li>
<li><code>.strides()</code>返回数组strides的指针。</li>
<li><code>.squeeze()</code>从给定数组的形状中删除一维的条目。</li>
<li><code>.view(dtype)</code>返回指定dtype类型的数组视图。</li>
<li><code>.reshape({i, j, ...})</code>返回指定shape的数组视图。<code>.resize({})</code>也可以。</li>
<li><code>.index_at(i, j, ...)</code>获取数组指定所以的元素。</li>
</ul>
<p>还有几种获取引用的方法(如下所述)。</p>
<h4 id="1223-结构体类型"><a class="header" href="#1223-结构体类型">12.2.3 结构体类型</a></h4>
<p>为了让<code>py::array_t</code>可以使用结构体类型，首先我们需要注册这个类型的内存布局。这可以通过<code>PYBIND11_NUMPY_DTYPE</code>宏来实现。</p>
<pre><code class="language-c++">struct A {
    int x;
    double y;
};

struct B {
    int z;
    A a;
};

// ...
PYBIND11_MODULE(test, m) {
    // ...

    PYBIND11_NUMPY_DTYPE(A, x, y);
    PYBIND11_NUMPY_DTYPE(B, z, a);
    /* now both A and B can be used as template arguments to py::array_t */
}
</code></pre>
<p>结构体需要是由基础算术类型、<code>std::complex</code>，之前已经注册的子结构体类型，<code>arrays</code>这些类型组成。支持C++数组和<code>std::array</code>。虽然有静态断言来防止不支持结构体类型的注册，使用者仍需负责地只使用plain结构体，这样可以安全的操作原始内存，而不会范围不变量。</p>
<h4 id="1224-向量化函数"><a class="header" href="#1224-向量化函数">12.2.4 向量化函数</a></h4>
<p>假设我们想要将一个如下签名的函数绑定到Python，想让他既能接收常规参数，又能接收任意NumPy数组参数（向量、矩阵、多维数组）。</p>
<pre><code class="language-c++">double my_func(int x, float y, double z);
</code></pre>
<p>包含<code>pybind11/numpy.h</code>后，这很好实现：</p>
<pre><code class="language-c++">m.def(&quot;vectorized_func&quot;, py::vectorize(my_func));
</code></pre>
<p>这样将对数组中每个元素调用函数进行处理。与<code>numpy.vectorize()</code>一类方案相比，该方案显著的优势是：元素处理的循环完全在c++端运行，编译器可以将其压缩成一个紧凑的、优化后的循环。函数函数值将返回NumPy 数组类型<code>numpy.dtype.float64</code>。</p>
<pre><code class="language-python">x = np.array([[1, 3], [5, 7]])
y = np.array([[2, 4], [6, 8]])
z = 3
result = vectorized_func(x, y, z)
</code></pre>
<p>标量<code>z</code>将透明地复制4次。输入数组<code>x</code>和<code>y</code>将自动转型为正确的类型（从<code>numpy.dtype.int64</code>转到需要的<code>numpy.dtype.int32</code>和<code>numpy.dtype.float32</code>）。</p>
<blockquote>
<p><strong>Note</strong></p>
<p>只有传值或常量引用的算术类型、复数、POD类型才能向量化，其他参数将原样传递。带右值引用参数的函数不能向量化。</p>
</blockquote>
<p>如果计算太过复杂而无法对其进行量化，就需要手动创建和访问缓冲区内容。下面的代码展示了这该如何进行。(the code is somewhat contrived, since it could have been done more simply using <code>vectorize</code>).</p>
<pre><code class="language-c++">#include &lt;pybind11/pybind11.h&gt;
#include &lt;pybind11/numpy.h&gt;

namespace py = pybind11;

py::array_t&lt;double&gt; add_arrays(py::array_t&lt;double&gt; input1, py::array_t&lt;double&gt; input2) {
    py::buffer_info buf1 = input1.request(), buf2 = input2.request();

    if (buf1.ndim != 1 || buf2.ndim != 1)
        throw std::runtime_error(&quot;Number of dimensions must be one&quot;);

    if (buf1.size != buf2.size)
        throw std::runtime_error(&quot;Input shapes must match&quot;);

    /* No pointer is passed, so NumPy will allocate the buffer */
    auto result = py::array_t&lt;double&gt;(buf1.size);

    py::buffer_info buf3 = result.request();

    double *ptr1 = static_cast&lt;double *&gt;(buf1.ptr);
    double *ptr2 = static_cast&lt;double *&gt;(buf2.ptr);
    double *ptr3 = static_cast&lt;double *&gt;(buf3.ptr);

    for (size_t idx = 0; idx &lt; buf1.shape[0]; idx++)
        ptr3[idx] = ptr1[idx] + ptr2[idx];

    return result;
}

PYBIND11_MODULE(test, m) {
    m.def(&quot;add_arrays&quot;, &amp;add_arrays, &quot;Add two NumPy arrays&quot;);
}
</code></pre>
<h4 id="1225-直接访问"><a class="header" href="#1225-直接访问">12.2.5 直接访问</a></h4>
<p>出于性能方面的考虑，尤其是处理大型数组时，我们通常希望直接访问数组元素（已确定索引有效），而不需要在每次访问时进行内部维数和边界检查。为了规避这些检查，<code>array</code>和<code>array_t&lt;T&gt;</code>模板类提供了不带检查的代理类<code>unchecked&lt;N&gt;</code>和<code>mutable_unchecked&lt;N&gt;</code>，其中<code>N</code>为数组所需的维数。</p>
<pre><code class="language-c++">m.def(&quot;sum_3d&quot;, [](py::array_t&lt;double&gt; x) {
    auto r = x.unchecked&lt;3&gt;(); // x must have ndim = 3; can be non-writeable
    double sum = 0;
    for (py::ssize_t i = 0; i &lt; r.shape(0); i++)
        for (py::ssize_t j = 0; j &lt; r.shape(1); j++)
            for (py::ssize_t k = 0; k &lt; r.shape(2); k++)
                sum += r(i, j, k);
    return sum;
});
m.def(&quot;increment_3d&quot;, [](py::array_t&lt;double&gt; x) {
    auto r = x.mutable_unchecked&lt;3&gt;(); // Will throw if ndim != 3 or flags.writeable is false
    for (py::ssize_t i = 0; i &lt; r.shape(0); i++)
        for (py::ssize_t j = 0; j &lt; r.shape(1); j++)
            for (py::ssize_t k = 0; k &lt; r.shape(2); k++)
                r(i, j, k) += 1.0;
}, py::arg().noconvert());
</code></pre>
<p>要从<code>array</code>对象获取代理，你必须同时制定数据类型和维数作为模板参数，如<code>auto r = myarray.mutable_unchecked&lt;float, 2&gt;()</code>。</p>
<p>如果在编译时不知道维度的数量，则可以省略维度模板参数（像这样<code>arr_t.unchecked()</code>、<code>arr.unchecked&lt;T&gt;()</code>）。这同样可以工作，只是会导致代码优化较少而有略微新能损失。</p>
<p>注意，返回的代理类时直接引用array的数据，只在构造时读取shape, strides, writeable flag。您必须确保所引用的数组在返回对象的持续时间内不会被销毁或reshape, typically by limiting the scope of the returned instance.</p>
<p>The returned proxy object supports some of the same methods as <code>py::array</code> so that it can be used as a drop-in replacement for some existing, index-checked uses of <code>py::array</code>:</p>
<ul>
<li><code>.ndim()</code> returns the number of dimensions</li>
<li><code>.data(1, 2, ...)</code> and <code>r.mutable_data(1, 2, ...)</code> returns a pointer to the <code>const T</code> or <code>T</code> data, respectively, at the given indices. The latter is only available to proxies obtained via <code>a.mutable_unchecked()</code>.</li>
<li><code>.itemsize()</code> returns the size of an item in bytes, i.e. <code>sizeof(T)</code>.</li>
<li><code>.ndim()</code> returns the number of dimensions.</li>
<li><code>.shape(n)</code> returns the size of dimension <code>n</code></li>
<li><code>.size()</code> returns the total number of elements (i.e. the product of the shapes).</li>
<li><code>.nbytes()</code> returns the number of bytes used by the referenced elements (i.e. <code>itemsize()</code> times <code>size()</code>).</li>
</ul>
<h4 id="1226-省略号"><a class="header" href="#1226-省略号">12.2.6 省略号</a></h4>
<p>Python 3 provides a convenient <code>...</code> ellipsis notation that is often used to slice multidimensional arrays. For instance, the following snippet extracts the middle dimensions of a tensor with the first and last index set to zero. In Python 2, the syntactic sugar <code>...</code> is not available, but the singleton <code>Ellipsis</code> (of type <code>ellipsis</code>) can still be used directly.</p>
<pre><code class="language-python">a = ...  # a NumPy array
b = a[0, ..., 0]
</code></pre>
<p>The function <code>py::ellipsis()</code> function can be used to perform the same operation on the C++ side:</p>
<pre><code class="language-c++">py::array a = /* A NumPy array */;
py::array b = a[py::make_tuple(0, py::ellipsis(), 0)];
</code></pre>
<h4 id="1227-内存视图"><a class="header" href="#1227-内存视图">12.2.7 内存视图</a></h4>
<p>当我们只想提供C/C++ buffer的访问接口而不用构造类对象时，我们可以返回一个<code>memoryview</code>对象。假设我们希望公开<code>2*4 uint8_t</code>数组的<code>memoryview</code>时，可以这样做：</p>
<pre><code class="language-c++">const uint8_t buffer[] = {
    0, 1, 2, 3,
    4, 5, 6, 7
};
m.def(&quot;get_memoryview2d&quot;, []() {
    return py::memoryview::from_buffer(
        buffer,                                    // buffer pointer
        { 2, 4 },                                  // shape (rows, cols)
        { sizeof(uint8_t) * 4, sizeof(uint8_t) }   // strides in bytes
    );
})
</code></pre>
<p>这样提供的<code>memoryview</code>不归Python管理，使用者有责任管理buffer的生命周期。在C++测删除buffer后继续使用创建的<code>memoryview</code>对象将导致未定义行为。</p>
<p>我们也可以使用<code>memoryview::from_memory</code>创建一个一维连续数组的内存视图：</p>
<pre><code class="language-c++">m.def(&quot;get_memoryview1d&quot;, []() {
    return py::memoryview::from_memory(
        buffer,               // buffer pointer
        sizeof(uint8_t) * 8   // buffer size
    );
})
</code></pre>
<blockquote>
<p>Note: <code>memoryview::from_memory</code> is not available in Python 2.</p>
</blockquote>
<h3 id="123-实用工具"><a class="header" href="#123-实用工具">12.3 实用工具</a></h3>
<h4 id="1231-在c中使用python-print函数"><a class="header" href="#1231-在c中使用python-print函数">12.3.1 在C++中使用Python print函数</a></h4>
<p>C++中通常使用<code>std::out</code>输出，而Python中则通常使用<code>print</code>。因为这些方法使用不同的缓冲区，混合使用它们可能会导致输出顺序问题。为解决这个问题，pybind11提供了<code>py::print</code>函数将输出写到Python的<code>sys.stdout</code>中。</p>
<p>函数包含了Python <code>print</code>一样的<code>sep</code>, <code>end</code>, <code>file</code>, <code>flush</code>等参数。</p>
<pre><code class="language-c++">py::print(1, 2.0, &quot;three&quot;); // 1 2.0 three
py::print(1, 2.0, &quot;three&quot;, &quot;sep&quot;_a=&quot;-&quot;); // 1-2.0-three

auto args = py::make_tuple(&quot;unpacked&quot;, true);
py::print(&quot;-&gt;&quot;, *args, &quot;end&quot;_a=&quot;&lt;-&quot;); // -&gt; unpacked True &lt;-
</code></pre>
<h4 id="1232-从ostream捕获标准输出"><a class="header" href="#1232-从ostream捕获标准输出">12.3.2 从ostream捕获标准输出</a></h4>
<p>C++库通常使用<code>std::cout</code>和<code>std::cerr</code>来打印输出，但它们和Python的标准<code>sys.stdout</code>和<code>sys.stderr</code>不能很好的协同工作。使用<code>py::print</code>代替库的打印是不现实的。我们可以将库函数的输出重定向到相应的Python streams来处理该问题：</p>
<pre><code class="language-C++">#include &lt;pybind11/iostream.h&gt;

...

// Add a scoped redirect for your noisy code
m.def(&quot;noisy_func&quot;, []() {
    py::scoped_ostream_redirect stream(
        std::cout,                               // std::ostream&amp;
        py::module_::import(&quot;sys&quot;).attr(&quot;stdout&quot;) // Python output
    );
    call_noisy_func();
});
</code></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p><code>pybind11/iostream.h</code>的实现不是线程安全的。多线程并发写入重定向的ostream将导致数据竞争和潜在的缓冲区溢出。因此，目前要求所有(可能的)并发重定向写入ostream都要有互斥锁保护。</p>
</blockquote>
<p>此方法会对输出流进行刷新，并在<code>scoped_ostream_redirect</code>被销毁时根据需要进行刷新。这允许实时地重定向输出，比如输出到Jupyter notebook。C++流和Python输出这两个参数是可选的，不指定时默认为标准输出。<code>py::scoped_estream_redirect &lt;scoped_estream_redirect&gt;</code>是作用于标准错误的。可以通过<code>py::call_guard</code>来简便设置。</p>
<pre><code class="language-c++">// Alternative: Call single function using call guard
m.def(&quot;noisy_func&quot;, &amp;call_noisy_function,
      py::call_guard&lt;py::scoped_ostream_redirect,
                     py::scoped_estream_redirect&gt;());
</code></pre>
<p>The redirection can also be done in Python with the addition of a context manager, using the <code>py::add_ostream_redirect() &lt;add_ostream_redirect&gt;</code> function:</p>
<pre><code class="language-c++">py::add_ostream_redirect(m, &quot;ostream_redirect&quot;);
</code></pre>
<p>The name in Python defaults to <code>ostream_redirect</code> if no name is passed. This creates the following context manager in Python:</p>
<pre><code class="language-python">with ostream_redirect(stdout=True, stderr=True):
    noisy_function()
</code></pre>
<p>It defaults to redirecting both streams, though you can use the keyword arguments to disable one of the streams if needed.</p>
<h4 id="1233-从字符串和文件执行python表达式"><a class="header" href="#1233-从字符串和文件执行python表达式">12.3.3 从字符串和文件执行Python表达式</a></h4>
<p>pybind11 provides the <code>eval</code>, <code>exec</code> and <code>eval_file</code> functions to evaluate Python expressions and statements. The following example illustrates how they can be used.</p>
<pre><code class="language-c++">// At beginning of file
#include &lt;pybind11/eval.h&gt;

...

// Evaluate in scope of main module
py::object scope = py::module_::import(&quot;__main__&quot;).attr(&quot;__dict__&quot;);

// Evaluate an isolated expression
int result = py::eval(&quot;my_variable + 10&quot;, scope).cast&lt;int&gt;();

// Evaluate a sequence of statements
py::exec(
    &quot;print('Hello')\n&quot;
    &quot;print('world!');&quot;,
    scope);

// Evaluate the statements in an separate Python file on disk
py::eval_file(&quot;script.py&quot;, scope);
</code></pre>
<p>C++11 raw string literals are also supported and quite handy for this purpose. The only requirement is that the first statement must be on a new line following the raw string delimiter <code>R&quot;(</code>, ensuring all lines have common leading indent:</p>
<pre><code class="language-c++">py::exec(R&quot;(
    x = get_answer()
    if x == 42:
        print('Hello World!')
    else:
        print('Bye!')
    )&quot;, scope
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="13-内嵌解释器"><a class="header" href="#13-内嵌解释器">13. 内嵌解释器</a></h2>
<p>虽然pybind11主要聚焦于使用C++扩展Python，反过来也是可以的，可以内嵌Python解释器到C++程序中。前面章节讲解的pybind11内容仍然适用。本节将介绍嵌入所需的一些额外内容。</p>
<h3 id="131-准备开始"><a class="header" href="#131-准备开始">13.1 准备开始</a></h3>
<p>创建一个内嵌解释器的程序，可以在Cmake中添加<code>pybind11::embed</code>来支持。</p>
<pre><code class="language-cmake">cmake_minimum_required(VERSION 3.4)
project(example)

find_package(pybind11 REQUIRED)  # or `add_subdirectory(pybind11)`

add_executable(example main.cpp)
target_link_libraries(example PRIVATE pybind11::embed)
</code></pre>
<p><code>main.cpp</code>的基本结构如下：</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt; // everything needed for embedding
namespace py = pybind11;

int main() {
    py::scoped_interpreter guard{}; // start the interpreter and keep it alive

    py::print(&quot;Hello, World!&quot;); // use the Python API
}
</code></pre>
<p>需要在使用任意Python API前初始化解释器，包括pybind11 Python函数和类。RAII guard类<code>scoped_interpreter</code>可用来管理解释器的生命周期。在guard类销毁时，解释器将会关闭并占用的内存。必须在所有Python函数前调用它。</p>
<h3 id="132-执行python代码"><a class="header" href="#132-执行python代码">13.2 执行Python代码</a></h3>
<p>在12.3.3节中，我们介绍了可以使用<code>eval</code>、<code>exec</code>和<code>eval_file</code>函数来执行Python表达式或语句。下面的例子展示了附带解释器来执行Python代码的流程：</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt;
namespace py = pybind11;

int main() {
    py::scoped_interpreter guard{};

    py::exec(R&quot;(
        kwargs = dict(name=&quot;World&quot;, number=42)
        message = &quot;Hello, {name}! The answer is {number}&quot;.format(**kwargs)
        print(message)
    )&quot;);
}
</code></pre>
<p>也可以使用pybind11 API来实现相同的功能（参考12章）。</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt;
namespace py = pybind11;
using namespace py::literals;

int main() {
    py::scoped_interpreter guard{};

    auto kwargs = py::dict(&quot;name&quot;_a=&quot;World&quot;, &quot;number&quot;_a=42);
    auto message = &quot;Hello, {name}! The answer is {number}&quot;_s.format(**kwargs);
    py::print(message);
}
</code></pre>
<p>两种方法也可以混合使用：</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt;
#include &lt;iostream&gt;

namespace py = pybind11;
using namespace py::literals;

int main() {
    py::scoped_interpreter guard{};

    auto locals = py::dict(&quot;name&quot;_a=&quot;World&quot;, &quot;number&quot;_a=42);
    py::exec(R&quot;(
        message = &quot;Hello, {name}! The answer is {number}&quot;.format(**locals())
    )&quot;, py::globals(), locals);

    auto message = locals[&quot;message&quot;].cast&lt;std::string&gt;();
    std::cout &lt;&lt; message;
}
</code></pre>
<h3 id="123-导入模块"><a class="header" href="#123-导入模块">12.3 导入模块</a></h3>
<p>使用<code>module_::import()</code>可以导入Python模块。</p>
<pre><code class="language-c++">py::module_ sys = py::module_::import(&quot;sys&quot;);
py::print(sys.attr(&quot;path&quot;));
</code></pre>
<p>为方便起见，内嵌解释器时，会将当前工作路径包含到<code>sys.path</code>中。这样我们可以方便地导入本地Python文件。</p>
<pre><code class="language-python">&quot;&quot;&quot;calc.py located in the working directory&quot;&quot;&quot;


def add(i, j):
    return i + j
</code></pre>
<pre><code class="language-c++">py::module_ calc = py::module_::import(&quot;calc&quot;);
py::object result = calc.attr(&quot;add&quot;)(1, 2);
int n = result.cast&lt;int&gt;();
assert(n == 3);
</code></pre>
<p>如果运行时源文件被修改（如被外部进程修改），可以使用<code>module_::reload()</code>重新导入模块。这在下面的场景中十分有用：有个应用程序要导入用户定义数据处理脚本，该脚本需要在用户修改后更新时。注意，这个函数不会递归地重新加载模块。</p>
<h3 id="124-添加内嵌模块"><a class="header" href="#124-添加内嵌模块">12.4 添加内嵌模块</a></h3>
<p>使用宏<code>PYBIND11_EMBEDDED_MODULE</code>可以添加内嵌的二进制模块。这个定义需要放在全局作用域中。定义后，他们可以向其他模块一样导入。</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt;
namespace py = pybind11;

PYBIND11_EMBEDDED_MODULE(fast_calc, m) {
    // `m` is a `py::module_` which is used to bind functions and classes
    m.def(&quot;add&quot;, [](int i, int j) {
        return i + j;
    });
}

int main() {
    py::scoped_interpreter guard{};

    auto fast_calc = py::module_::import(&quot;fast_calc&quot;);
    auto result = fast_calc.attr(&quot;add&quot;)(1, 2).cast&lt;int&gt;();
    assert(result == 3);
}
</code></pre>
<p>Unlike extension modules where only a single binary module can be created, on the embedded side an unlimited number of modules can be added using multiple <code>PYBIND11_EMBEDDED_MODULE</code> definitions (as long as they have unique names).</p>
<p>These modules are added to Python’s list of builtins, so they can also be imported in pure Python files loaded by the interpreter. Everything interacts naturally:</p>
<pre><code class="language-c++">&quot;&quot;&quot;py_module.py located in the working directory&quot;&quot;&quot;
import cpp_module

a = cpp_module.a
b = a + 1
#include &lt;pybind11/embed.h&gt;
namespace py = pybind11;

PYBIND11_EMBEDDED_MODULE(cpp_module, m) {
    m.attr(&quot;a&quot;) = 1;
}

int main() {
    py::scoped_interpreter guard{};

    auto py_module = py::module_::import(&quot;py_module&quot;);

    auto locals = py::dict(&quot;fmt&quot;_a=&quot;{} + {} = {}&quot;, **py_module.attr(&quot;__dict__&quot;));
    assert(locals[&quot;a&quot;].cast&lt;int&gt;() == 1);
    assert(locals[&quot;b&quot;].cast&lt;int&gt;() == 2);

    py::exec(R&quot;(
        c = a + b
        message = fmt.format(a, b, c)
    )&quot;, py::globals(), locals);

    assert(locals[&quot;c&quot;].cast&lt;int&gt;() == 3);
    assert(locals[&quot;message&quot;].cast&lt;std::string&gt;() == &quot;1 + 2 = 3&quot;);
}
</code></pre>
<h3 id="125-解释器的生命周期"><a class="header" href="#125-解释器的生命周期">12.5 解释器的生命周期</a></h3>
<p>当 <code>scoped_interpreter</code> 销毁时，程序会自动关闭Python解释器。后面再创建一个新的示例会重启解释器。或者，我们也可以使用 <code>initialize_interpreter</code> / <code>finalize_interpreter</code> 这组函数在任意时刻直接设置解释器状态。</p>
<p>解释器重启后，pybind11创建的模块可以安全地重新初始化，但第三方扩展模块可能会有些问题。问题在于Python本身不能完全卸载扩展模块，并且会有一些解释器重启的警告。简而言之，由于Python引用循环或用户创建的全局数据，并非所有内存都可能被释放。具体细节可以查看CPython文档。</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>Creating two concurrent <code>scoped_interpreter</code> guards is a fatal error. So is calling <code>initialize_interpreter</code> for a second time after the interpreter has already been initialized.</p>
<p>Do not use the raw CPython API functions <code>Py_Initialize</code> and <code>Py_Finalize</code> as these do not properly handle the lifetime of pybind11’s internal data.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="14-杂项"><a class="header" href="#14-杂项">14. 杂项</a></h2>
<h3 id="141-关于便利宏的说明"><a class="header" href="#141-关于便利宏的说明">14.1 关于便利宏的说明</a></h3>
<p>pybind11提供了一些便利宏如<code>PYBIND11_DECLARE_HOLDER_TYPE()</code>和<code>PYBIND11_OVERRIDE_*</code>。由于这些宏只是在预处理中计算(预处理程序没有类型的概念)，它们会被模板参数中的逗号搞混。如：</p>
<pre><code class="language-c++">PYBIND11_OVERRIDE(MyReturnType&lt;T1, T2&gt;, Class&lt;T3, T4&gt;, func)
</code></pre>
<p>预处理器会将其解释为5个参数（逗号分隔），而不是3个。有两种方法可以处理这个问题：使用类型别名，或者使用<code>PYBIND11_TYPE</code>包裹类型。</p>
<pre><code class="language-c++">// Version 1: using a type alias
using ReturnType = MyReturnType&lt;T1, T2&gt;;
using ClassType = Class&lt;T3, T4&gt;;
PYBIND11_OVERRIDE(ReturnType, ClassType, func);

// Version 2: using the PYBIND11_TYPE macro:
PYBIND11_OVERRIDE(PYBIND11_TYPE(MyReturnType&lt;T1, T2&gt;),
                  PYBIND11_TYPE(Class&lt;T3, T4&gt;), func)
</code></pre>
<p><code>PYBIND11_MAKE_OPAQUE</code>宏不需要上述解决方案。</p>
<h3 id="142-全局解释器锁gil"><a class="header" href="#142-全局解释器锁gil">14.2 全局解释器锁（GIL）</a></h3>
<p>在Python中调用C++函数时，默认会持有GIL。<code>gil_scoped_release</code>和<code>gil_scoped_acquire</code>可以方便地在函数体中释放和获取GIL。这样长时间运行的C++代码可以通过Python线程实现并行化。示例如下：</p>
<pre><code class="language-c++">class PyAnimal : public Animal {
public:
    /* Inherit the constructors */
    using Animal::Animal;

    /* Trampoline (need one for each virtual function) */
    std::string go(int n_times) {
        /* Acquire GIL before calling Python code */
        py::gil_scoped_acquire acquire;

        PYBIND11_OVERRIDE_PURE(
            std::string, /* Return type */
            Animal,      /* Parent class */
            go,          /* Name of function */
            n_times      /* Argument(s) */
        );
    }
};

PYBIND11_MODULE(example, m) {
    py::class_&lt;Animal, PyAnimal&gt; animal(m, &quot;Animal&quot;);
    animal
        .def(py::init&lt;&gt;())
        .def(&quot;go&quot;, &amp;Animal::go);

    py::class_&lt;Dog&gt;(m, &quot;Dog&quot;, animal)
        .def(py::init&lt;&gt;());

    m.def(&quot;call_go&quot;, [](Animal *animal) -&gt; std::string {
        /* Release GIL before calling into (potentially long-running) C++ code */
        py::gil_scoped_release release;
        return call_go(animal);
    });
}
</code></pre>
<p>我们可以使用<code>call_guard</code>策略来简化<code>call_go</code>的封装：</p>
<pre><code class="language-c++">m.def(&quot;call_go&quot;, &amp;call_go, py::call_guard&lt;py::gil_scoped_release&gt;());
</code></pre>
<h3 id="143-通过多个模块来划分代码"><a class="header" href="#143-通过多个模块来划分代码">14.3 通过多个模块来划分代码</a></h3>
<p>通常我们可以直接将绑定代码分隔到多个模块中，即便模块引用的类型在其他模块中定义。有个例外场景，就是当前扩展的类型定义在其他模块中，参见下面的例子：</p>
<pre><code class="language-c++">py::class_&lt;Pet&gt; pet(m, &quot;Pet&quot;);
pet.def(py::init&lt;const std::string &amp;&gt;())
   .def_readwrite(&quot;name&quot;, &amp;Pet::name);

py::class_&lt;Dog&gt;(m, &quot;Dog&quot;, pet /* &lt;- specify parent */)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def(&quot;bark&quot;, &amp;Dog::bark);
</code></pre>
<p>假设<code>Pet</code>类的绑定定义在<code>basic</code>模块中，而<code>Dog</code>绑定定义在其他模块。在<code>class_&lt;Dog&gt;</code>中明确与<code>Pet</code>类的继承关系时需要知道<code>Pet</code>，问题是在其他模块定义的<code>Pet</code>不再对<code>Dog</code>可见。我们可以这样处理：</p>
<pre><code class="language-c++">py::object pet = (py::object) py::module_::import(&quot;basic&quot;).attr(&quot;Pet&quot;);

py::class_&lt;Dog&gt;(m, &quot;Dog&quot;, pet)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def(&quot;bark&quot;, &amp;Dog::bark);
</code></pre>
<p>或者，你可以将基类作为模板参数给<code>class_</code>，让pybind11自动查找到相应的Python类型。但也需要调用一次<code>import</code>函数，确保<code>basic</code>模块的绑定代码已经执行。</p>
<pre><code class="language-c++">py::module_::import(&quot;basic&quot;);

py::class_&lt;Dog, Pet&gt;(m, &quot;Dog&quot;)
    .def(py::init&lt;const std::string &amp;&gt;())
    .def(&quot;bark&quot;, &amp;Dog::bark);
</code></pre>
<p>如果存在循环依赖时，上述两种方法都将失效。</p>
<p>注意，pybind11代码在编译时会默认隐藏符号的可见性（如通过GCC/Clang的<code>-fvisibility=hidden</code>标识），这会干扰访问在其他模块定义的类型的能力。这需要通过手动导出需要被其他模块访问的类型，像这样：</p>
<pre><code class="language-c++">class PYBIND11_EXPORT Dog : public Animal {
    ...
};
</code></pre>
<p>在运行时也可以共享任意的C++对象，尽管很少用到该特性。使用capsule机制在模块间共享内部库数据，可以用来存储、修改、访问用户自定义数据。注意，一个模块能够看到其他模块的数据，仅在他们使用相同的pybind11版本编译时才能实现。参考下面的例子：</p>
<pre><code class="language-c++">auto data = reinterpret_cast&lt;MyData *&gt;(py::get_shared_data(&quot;mydata&quot;));
if (!data)
    data = static_cast&lt;MyData *&gt;(py::set_shared_data(&quot;mydata&quot;, new MyData(42)));
</code></pre>
<p>如果在几个单独编译的扩展模块中使用了上述代码段，第一个导入的模块将创建<code>MyData</code>实例，并和指针联系起来。后续导入的模块就可以访问该指针指向的数据了。</p>
<h3 id="144-模块析构"><a class="header" href="#144-模块析构">14.4 模块析构</a></h3>
<p>pybind11没有提供明确的机制在模块析构时调用清理代码。在少数需要该功能的场景下，可以使用Python capsules或析构回调函数的弱引用来模仿它。</p>
<pre><code class="language-c++">auto cleanup_callback = []() {
    // perform cleanup here -- this function is called with the GIL held
};

m.add_object(&quot;_cleanup&quot;, py::capsule(cleanup_callback));
</code></pre>
<p>该方法一个潜在地缺陷是，在cleanup函数调用时，模块公开的类实例可能仍存活着（这是否可以接受通常取决于应用程序）。</p>
<p>或者，我们可以将capsule存储在类型对象中，确保它不会在回收该类型的所有实例之前被调用：</p>
<pre><code class="language-c++">auto cleanup_callback = []() { /* ... */ };
m.attr(&quot;BaseClass&quot;).attr(&quot;_cleanup&quot;) = py::capsule(cleanup_callback);
</code></pre>
<p>上面的方法都在Python中暴露了一个<code>_cleanup</code>的危险属性，从API的角度来看，这种做法并不受欢迎（Python过早的显式调用它可能会导致未定义行为）。这可以通过使用cleanup函数回调的弱引用来规避。</p>
<pre><code class="language-c++">// Register a callback function that is invoked when the BaseClass object is collected
py::cpp_function cleanup_callback(
    [](py::handle weakref) {
        // perform cleanup here -- this function is called with the GIL held

        weakref.dec_ref(); // release weak reference
    }
);

// Create a weak reference with a cleanup callback and initially leak it
(void) py::weakref(m.attr(&quot;BaseClass&quot;), cleanup_callback).release();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="15-常见问题"><a class="header" href="#15-常见问题">15. 常见问题</a></h2>
<h3 id="151-importerror-dynamic-module-does-not-define-init-function"><a class="header" href="#151-importerror-dynamic-module-does-not-define-init-function">15.1 “ImportError: dynamic module does not define init function”</a></h3>
<ol>
<li>确保<code>PYBIND11_MODULE</code>中指定的名称与扩展库的文件名相同（没有后缀，例如.so）。</li>
<li>如果上述问题没有解决，您可能使用了不兼容的<code>Python</code>版本（例如，扩展库是针对<code>Python2</code>编译的，而解释器是在<code>Python3</code>的某些版本上运行的）。</li>
</ol>
<h3 id="152-symbol-not-found-__py_zerostruct-_pyinstancemethod_type"><a class="header" href="#152-symbol-not-found-__py_zerostruct-_pyinstancemethod_type">15.2 “Symbol not found: __Py_ZeroStruct _PyInstanceMethod_Type”</a></h3>
<p>参见15.1</p>
<h3 id="153-systemerror-dynamic-module-not-initialized-properly"><a class="header" href="#153-systemerror-dynamic-module-not-initialized-properly">15.3 “SystemError: dynamic module not initialized properly”</a></h3>
<p>参见15.1</p>
<h3 id="154-导入模块时python解释器立即崩溃"><a class="header" href="#154-导入模块时python解释器立即崩溃">15.4 导入模块时，Python解释器立即崩溃</a></h3>
<p>参见15.1</p>
<h3 id="155涉及引用参数的限制"><a class="header" href="#155涉及引用参数的限制">15.5涉及引用参数的限制</a></h3>
<p>在<code>C++</code>中，使用可变引用或可变指针传递参数是很常见的，这两种方法都允许读取并对调用者提供的值进行写访问。这有时是出于效率原因或为了实现具有多个返回值的函数。这里有两个非常基本的例子：</p>
<pre><code class="language-c++">void increment(int &amp;i) 
{ 
    i++; 
}
void increment_ptr(int *i) 
{ 
    (*i)++; 
}
</code></pre>
<p>在<code>Python</code>中，所有参数都是通过引用传递的，因此从Python绑定此类代码时一般不会有问题。 但是，某些基本<code>Python</code>类型（如<code>str</code>、<code>int</code>、<code>bool</code>、<code>float</code>
等）是不可变的。这意味着尝试将函数移植到<code>Python</code>后，对调用者提供的值不会产生相同的影响，事实上，它啥都没干。</p>
<pre><code class="language-python">def increment(i):
    i += 1  # nope..
</code></pre>
<p><code>pybind11</code>也受到此类语言级约定的影响，这意味着绑定<code>increment</code>或者<code>increment_ptr</code>还将创建不修改其参数的<code>Python</code>
函数。虽然不方便，但一种解决方法是将不可变类型封装在允许修改的自定义类型中影响。另一种选择涉及绑定一个小包装<code>lambda</code>函数，该函数返回一个包含所有输出参数的元组 （有关绑定<code>lambda</code>函数的示例，请参阅文档的其余部分）。例如：</p>
<pre><code class="language-c++">int foo(int &amp;i) 
{ 
    i++; 
    return 123; 
}
</code></pre>
<p>绑定代码为:</p>
<pre><code class="language-c++">m.def(&quot;foo&quot;, 
    [](int i) {
        int rv = foo(i); 
        return std::make_tuple(rv, i); 
    });
</code></pre>
<h3 id="156-如何减少编译时间"><a class="header" href="#156-如何减少编译时间">15.6 如何减少编译时间?</a></h3>
<p>在多个文件上拆分绑定代码是一种很好的做法，如下例所示：
<code>example.cpp</code></p>
<pre><code class="language-c++">void init_ex1(py::module_ &amp;);
void init_ex2(py::module_ &amp;);
/* ... */
PYBIND11_MODULE(example, m) {
    init_ex1(m);
    init_ex2(m);
    /* ... */ 
}
</code></pre>
<p><code>ex1.cpp</code>:</p>
<pre><code class="language-c++">void init_ex1(py::module_ &amp;m) {
    m.def(&quot;add&quot;, 
        [](int a, int b) { 
            return a + b; 
        });
}
</code></pre>
<p><code>ex2.cpp</code>:</p>
<pre><code class="language-c++">void init_ex2(py::module_ &amp;m) {
    m.def(&quot;sub&quot;, 
    [](int a, int b) { 
        return a - b; 
    });
}
</code></pre>
<p><code>python</code>调用：</p>
<pre><code class="language-python">import example

example.add(1, 2)  # 3
example.sub(1, 1)  # 0
</code></pre>
<p>如上所示，各种<code>init_ex</code>函数应该包含在单独的文件中，这些文件可以彼此独立编译，然后链接到同一个最终共享对象中。采用这种方法将有以下好处：</p>
<ol>
<li>减少每个编译单元的内存需求。</li>
<li>启用并行构建（如果需要）。</li>
<li>允许更快的增量构建。例如，当更改单个类定义时，只有绑定代码通常需要重新编译。</li>
</ol>
<h3 id="157-recursive-template-instantiation-exceeded-maximum-depth-of-256"><a class="header" href="#157-recursive-template-instantiation-exceeded-maximum-depth-of-256">15.7 “recursive template instantiation exceeded maximum depth of 256”</a></h3>
<p>如果得到关于超出递归模板深度的错误，请尝试指定更大的值，例如<code>GCC/Clang</code>上的<code>-ftemplate-depth=1024</code>编译标识。其罪魁祸首通常是使用C++14模板元编程在编译时生成函数签名。</p>
<h3 id="158-someclass-declared-with-greater-visibility-than-the-type-of-its-field-someclassmember--wattributes"><a class="header" href="#158-someclass-declared-with-greater-visibility-than-the-type-of-its-field-someclassmember--wattributes">15.8 “‘SomeClass’ declared with greater visibility than the type of its field ‘SomeClass::member’ [-Wattributes]”</a></h3>
<p>该错误通常表示在编译时没有使用所需的<code>-fvisibility</code>标志.pybind11代码从内部强制所有内部代码的隐藏可见性，但如果非隐藏（并因此导出），代码将尝试包括
pybind类型（例如，<code>py::object</code>或<code>py::list</code>）可能会遇到此警告。为了避免这种情况，请确保在编译pybind代码时指定<code>-fvisibility=hidden</code>。
至于为什么<code>-fvisibility=hidden</code>是必要的，因为<code>pybind</code>模块可以在<code>pybind</code>本身的不同版本下编译，同样重要的是，一个模块中定义的符号不会与
在另一个数据库中定义的潜在不兼容符号。虽然<code>Python</code>扩展模块通常加载本地化的符号（在<code>POSIX</code>系统下，通常使用带有<code>RTLD_local</code>标志的<code>dlopen</code>），但这个<code>Python</code>默认值
可以改变，但当不使用<code>-fvisibility=hidden</code>时,即使不改变，也不总是足以保证所涉及符号的完全独立性.
此外，<code>-fvisibility=hidden</code>可以显著节省二进制大小。（有关详细信息，请参见后续章节.)</p>
<h3 id="159-如何创建更小的二进制文件"><a class="header" href="#159-如何创建更小的二进制文件">15.9 如何创建更小的二进制文件?</a></h3>
<p>为了完成它的工作，<code>pybind11</code>
广泛依赖一种称为模板元编程的编程技术，这是一种在编译时使用类型信息执行计算的方法。模板元编程通常会实例化涉及大量深度嵌套类型的代码，这些类型在编译器的优化阶段要么被完全删除，要么被缩减为仅几条指令。但是，由于这些类型的嵌套性质，编译的扩展库中生成的符号名称可能非常长。例如，包含的测试套件包含以下符号：</p>
<pre><code class="language-bash">__ZN8pybind1112cpp_functionC1Iv8Example2JRNSt3__16vectorINS3_12basic_stringIwNS3_
11char_traitsIwEENS3_9allocatorIwEEEENS8_ISA_EEEEEJNS_4nameENS_7siblingENS_9is_
methodEA28_cEEEMT0_FT_DpT1_EDpRKT2_
</code></pre>
<p>这是以下函数类型的展开形式：</p>
<pre><code class="language-bash">pybind11::cpp_function::cpp_function&lt;void, Example2, std::__1::vector&lt;std::__1::basic_
string&lt;wchar_t, std::__1::char_traits&lt;wchar_t&gt;, std::__1::allocator&lt;wchar_t&gt; &gt;, 
std::__1::allocator&lt;std::__1::basic_string&lt;wchar_t, std::__1::char_traits&lt;wchar_t&gt;, 
std::__1::allocator&lt;wchar_t&gt; &gt; &gt; &gt;&amp;, pybind11::name, pybind11::sibling,
pybind11::is_method, char [28]&gt;(void (Example2::*)(std::__1::vector&lt;std::__1::basic_
string&lt;wchar_t, std::__1::char_traits&lt;wchar_t&gt;, std::__1::allocator&lt;wchar_t&gt; &gt;, 
std::__1::allocator&lt;std::__1::basic_string&lt;wchar_t, std::__1::char_traits&lt;wchar_t&gt;,
std::__1::allocator&lt;wchar_t&gt; &gt; &gt; &gt;&amp;), pybind11::name const&amp;, pybind11::sibling
const&amp;, pybind11::is_method const&amp;, char const (&amp;) [28])
</code></pre>
<p>仅存储此函数的错位名称（196 字节）所需的内存大于它所代表的实际代码段（111
字节）！另一方面，甚至给这个函数起个名字都是愚蠢的——毕竟，它只是一个更大的机器中的一个小齿轮，不暴露于外界。因此，我数
<code>-fvisibility=hidden</code>来实现，它将默认符号可见性设置为隐藏，这对生成的扩展库的最终二进制大小有巨大影响。 （在 <code>Visual Studio</code>
上，默认情况下符号已隐藏，因此无需在此处进行任何操作。）除了减小二进制大小之外，<code>-fvisibility=hidden</code>还可以避免在加载多个模块时出现潜在的严重问题，并且是正确
pybind们通常只想为那些实际从外部调用的函数导出符号。这可以通过为<code>GCC</code>和<code>Clang</code>指定参
操作所必需的。有关更多详细信息，请参阅之前的常见问题解答条目。</p>
<h3 id="1510-使用古老的基于windows的visual-studio-2008"><a class="header" href="#1510-使用古老的基于windows的visual-studio-2008">15.10 使用古老的基于Windows的Visual Studio 2008</a></h3>
<p><code>Python</code>的官方<code>Windows</code>发行版是使用缺乏良好 <code>C++11</code>支持的真正古老版本的 <code>Visual Studio</code>编译的。一些用户隐含地假设不可能将使用 <code>Visual Studio 2015</code>
构建的插件加载到使用 <code>Visual Studio 2008</code>编译的<code>Python</code>发行版中。但是，不存在这样的问题：接口使用不同编译器构建的<code>DLL</code>是完全合法的，并且/或<code>C</code>库。需要注意的常见问题包括在另一个共享库中使用<code>malloc()</code>编辑的非<code>free()</code>
内存区域，使用具有不兼容<code>ABI</code>的数据结构，等等。<code>pybind11</code> 非常小心不要犯这些类型的错误。</p>
<h3 id="1511-如何在长时间运行的函数中正确处理ctrl-c"><a class="header" href="#1511-如何在长时间运行的函数中正确处理ctrl-c">15.11 如何在长时间运行的函数中正确处理<code>Ctrl-C</code>？</a></h3>
<p><code>Ctrl-C</code>被<code>Python</code>解释器接收，并一直保持到<code>GIL</code>被释放，所以一个长时间运行的函数不会被中断。要从函数内部中断，您可以使用 PyErr_CheckSignals() 函数，该函数将判断 Python
端是否已发出信号。这个函数只检查一个标志，所以它的影响可以忽略不计。接收到信号后，您必须通过抛出 py::error_already_set 显式中断执行（这将传播现有的
KeyboardInterrupt），或者清除错误（您通常不希望这样做）：</p>
<pre><code class="language-c++">PYBIND11_MODULE(example, m){
    m.def(&quot;long running_func&quot;, 
        [](){
            for (;;) 
            {
                if (PyErr_CheckSignals() != 0)
                throw py::error_already_set();
                // Long running iteration
            }
            });
}
</code></pre>
<h3 id="1512-cmake未检测到正确的python版本"><a class="header" href="#1512-cmake未检测到正确的python版本">15.12 <code>CMake</code>未检测到正确的<code>Python</code>版本</a></h3>
<p>基于<code>CMake</code>的构建系统将尝试自动检测已安装的<code>Python</code>版本并与之链接。如果此操作失败，或者有多个版本的<code>Python</code>并找到错误的版本，请删除<code>CMakeCache.txt</code>
，然后将<code>-DPYTHON_EXECUTABLE=$(which python)</code>添加到<code>CMake</code>配置行。（如果您愿意，请将<code>$(which python)</code>替换为<code>python</code>
的路径。）您也可以尝试<code>-DPYBIND11_FINDPYTHON=ON</code>，这将激活新的<code>CMake FindPython</code>支持而不是<code>pybind11</code>的自定义搜索。需要<code>CMake 3.12+，3.15+</code>或<code>3.18.2+</code>
更好。您也可以在添加或查找<code>pybind11</code>之前在<code>CMakeLists.txt</code>中进行设置。</p>
<h3 id="1513-cmake和pybind11中python版本检测不一致"><a class="header" href="#1513-cmake和pybind11中python版本检测不一致">15.13 <code>CMake</code>和<code>pybind11</code>中<code>Python</code>版本检测不一致</a></h3>
<p><code>CMake</code>提供的用于<code>Python</code>版本检测的函数<code>find_package(PythonInterp)</code>和<code>find_package(PythonLibs)</code>被<code>pybind11</code>修改，原因是它们不适合<code>pybind11</code>
的需要。相反，<code>pybind11</code>提供了自己的、更可靠的<code>Python</code>检测<code>CMake</code>代码。但是，当在安装了多个<code>Python</code>版本的系统中使用<code>CMake Python</code>检测的项目中使用<code>pybind11</code>时，可能会出现冲突。
如果在同一个项目中使用这两种机制，这种差异可能会导致不一致和错误。考虑在安装了<code>Python2.7</code>和<code>3.x</code>的系统中执行的以下<code>CMake</code>代码：</p>
<pre><code class="language-cmake">find_package(PythonInterp)
find_package(PythonLibs)
find_package(pybind11)
</code></pre>
<p>它将检测<code>Python2.7</code>，<code>pybind11</code>也会选择它。
相比之下，这段代码：</p>
<pre><code class="language-cmake">find_package(pybind11)
find_package(PythonInterp)
find_package(PythonLibs)
</code></pre>
<p>将为<code>pybind11</code>检测<code>Python3.x</code>，之后可能会在<code>find_package(PythonLibs)</code>上崩溃。
有三种可能的解决方案：</p>
<ol>
<li>避免使用<code>CMake</code>中的<code>find_package(PythonInterp)</code>和<code>find_package(PythonLibs)</code>并依赖<code>pybind11</code>检测<code>Python</code>版本。如果这不可能，则应在包含<code>pybind11</code>
之前调用<code>CMake</code>机器。</li>
<li>将<code>PYBIND11_FINDPYTHON</code>设置为<code>True</code>或在现代<code>CMake</code>上使用<code>find_package(Python COMPONENTS Interpreter Development)</code>
（3.12+，3.15+更好，3.18.2+ 最好）。在这些情况下，<code>Pybind11</code>使用新的<code>CMake FindPython</code>而不是旧的、已弃用的搜索工具，并且这些模块在查找正确的<code>Python</code>方面要好得多。</li>
<li>将<code>PYBIND11_NOPYTHON</code>设置为<code>TRUE</code>。<code>Pybind11</code>不会搜索<code>Python</code>。但是，您将不得不使用基于目标的系统，并自己进行更多设置，因为它不知道或不包含依赖于<code>Python</code>
的东西，例如<code>pybind11_add_module</code>。这可能非常适合集成到现有系统中，例如<code>scikit-build</code>的<code>Python</code>助手。</li>
</ol>
<h3 id="1514-如何引用这个项目"><a class="header" href="#1514-如何引用这个项目">15.14 如何引用这个项目？</a></h3>
<p>我们建议使用以下 BibTeX 模板在科学话语中引用 pybind11：</p>
<pre><code class="language-bash">@misc{pybind11,
author = {Wenzel Jakob and Jason Rhinelander and Dean Moldovan},
year = {2017},
note = {https://github.com/pybind/pybind11},
title = {pybind11 -- Seamless operability between C++11 and Python} }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
